<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git的使用心得</title>
      <link href="posts/547feeee.html"/>
      <url>posts/547feeee.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Git在Windows上的安装"><a href="#1-Git在Windows上的安装" class="headerlink" title="1.Git在Windows上的安装"></a>1.Git在Windows上的安装</h2><p>官方版本可以在 Git 官方网站下载。 打开 <a href="https://git-scm.com/download/win%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E5%8D%B3%E5%8F%AF%E3%80%82">https://git-scm.com/download/win，下载安装即可。</a></p><h2 id="2-Git的配置"><a href="#2-Git的配置" class="headerlink" title="2.Git的配置"></a>2.Git的配置</h2><p>安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git config --global user.name "li-niuniu"$ git config --global user.email myloveislizihao@163.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h4><p>如果想要检查你的配置，可以使用 <code>git config --list</code> 命令来列出所有 Git 当时能找到的配置。</p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924125903265.png"></p><h2 id="3-Git文件的各种状态"><a href="#3-Git文件的各种状态" class="headerlink" title="3.Git文件的各种状态"></a>3.Git文件的各种状态</h2><h4 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h4><p>一般工作流程如下：</p><ul><li>克隆 Git 资源作为工作目录。</li><li>在克隆的资源上添加或修改文件。</li><li>如果其他人修改了，你可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。</li><li>推送到远程库</li></ul><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924165839084.png"></p><h4 id="Git的工作区、暂存区和版本库"><a href="#Git的工作区、暂存区和版本库" class="headerlink" title="Git的工作区、暂存区和版本库"></a>Git的工作区、暂存区和版本库</h4><ul><li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li><li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924170020844.png"></p><h4 id="文件的已追踪和未追踪"><a href="#文件的已追踪和未追踪" class="headerlink" title="文件的已追踪和未追踪"></a>文件的已追踪和未追踪</h4><p>工作目录下的每一个文件都不外乎这两种状态：<strong>已跟踪</strong> 或 <strong>未跟踪</strong>。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是 Git 已经知道的文件。</p><p>工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们。</p><p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 在工作时，你可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。</p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/lifecycle.png"></p><h4 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h4><p>克隆仓库的命令是 <code>git clone &lt;url&gt;</code> 。 比如，要克隆提交作业的仓库，可以用下面的命令：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git clone https://gitee.com/fengjie_zstu/graduate-single-program2021.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h4><p>可以用 <code>git status</code> 命令查看哪些文件处于什么状态。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924140554567.png"></p><p>所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。</p><p>现在，创建一个新的<code>test/test.txt</code>文件。 如果之前并不存在这个文件，使用 <code>git status</code> 命令，你将看到一个新的未跟踪文件：</p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924142740202.png"></p><p>使用命令 <code>git add</code>可以跟踪一个文件。 所以，要跟踪 <code>test/test.txt</code> 文件，运行：</p><pre class="line-numbers language-none"><code class="language-none">git add test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时再运行 <code>git status</code> 命令，会看到 <code>test/test.txt</code> 文件已被跟踪，并处于暂存状态:</p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924143124340.png"></p><p>如果修改一个已被跟踪的文件，运行<code>git add</code>命令可以重新放到暂存区</p><h4 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h4><p>已修改但未暂存的文件只会保留在本地磁盘。 所以，每次准备提交前，先用 <code>git status</code> 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>：</p><pre class="line-numbers language-none"><code class="language-none">git commit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924144147905.png"></p><h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。</p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924144625010.png"></p><h4 id="去掉已经托管在本地的文件"><a href="#去掉已经托管在本地的文件" class="headerlink" title="去掉已经托管在本地的文件"></a>去掉已经托管在本地的文件</h4><p>如果想去掉已经托管在本地的文件，将文件变为未追踪的文件，可以使用<code>git rm</code>命令：</p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924165155686.png"></p><h2 id="4-远程仓库"><a href="#4-远程仓库" class="headerlink" title="4.远程仓库"></a>4.远程仓库</h2><h4 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote -v</code>  命令。 它会列出你指定的每一个远程服务器的简写和对应的URL。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字：</p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924145511192.png"></p><h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写：</p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924145802838.png"></p><p>现在可以在命令行中使用字符串 <code>abc</code> 来代替整个 URL。 例如，如果你想拉取URL对应的仓库中有但你没有的信息，可以运行 <code>git pull origin</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924150355597.png"></p><p>这说明目前远程仓库的内容已经全部被抓取到本地仓库</p><h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><p>当你想分享你的项目时，必须将其推送到上游。 这个命令：<code>git push &lt;remote&gt; &lt;branch&gt;</code>。 当你想要将 <code>master</code> 分支推送到 <code>origin</code> 服务器时（克隆时通常会自动帮你设置好那两个名字）， 那么运行这个命令就可以将你所做的备份到服务器：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924151226584.png"></p><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。</p><h4 id="远程仓库的重命名与移除"><a href="#远程仓库的重命名与移除" class="headerlink" title="远程仓库的重命名与移除"></a>远程仓库的重命名与移除</h4><p>以运行 <code>git remote rename</code> 来修改一个远程仓库的简写名。 例如，想要将 <code>abc</code> 重命名为 <code>def</code>，可以用 <code>git remote rename</code> 这样做：</p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924151528374.png"></p><p>值得注意的是这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 <code>abc/master</code> 的现在会引用 <code>def/master</code>。</p><p>如果想要移除一个远程仓库,可以使用 <code>git remote remove</code> 或 <code>git remote rm</code> ：</p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924151808763.png"></p><h2 id="5-Git分支"><a href="#5-Git分支" class="headerlink" title="5.Git分支"></a>5.Git分支</h2><h3 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h3><p>Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 <code>git branch</code> 命令：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">$ git branch testing<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这会在当前所在的提交对象上创建一个指针。</p><p>当需要在非当前分支上工作时，需要使用<code>git checkout</code>命令:</p><pre class="line-numbers language-none"><code class="language-none">$ git checkout testing<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>某些场景下，需要合并两个分支，则需要使用<code>git merge</code>命令:</p><pre class="line-numbers language-none"><code class="language-none">$ git checkout master$ git merge testing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样testing分支中的内容会合并至master之中</p><h2 id="6-在Intellij-Idea中暂存，提交并推送"><a href="#6-在Intellij-Idea中暂存，提交并推送" class="headerlink" title="6.在Intellij Idea中暂存，提交并推送"></a>6.在Intellij Idea中暂存，提交并推送</h2><h4 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h4><p>当做了更改之后，</p><p>右键文件，点击git分支下的add，将其放到暂存区中</p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924174240592.png"></p><h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><p>点击git分支下的commit file，并在弹出的对话框中输入提交信息，将其提交本地库中</p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924174427415.png"></p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924174600718.png"></p><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>点击右下角branch分支，核对本地分支及远程库之后，点击local branches下的branch，点击push即可</p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924174715285.png"></p><h2 id="7-在Vscode中暂存，提交并推送"><a href="#7-在Vscode中暂存，提交并推送" class="headerlink" title="7.在Vscode中暂存，提交并推送"></a>7.在Vscode中暂存，提交并推送</h2><h4 id="暂存-1"><a href="#暂存-1" class="headerlink" title="暂存"></a>暂存</h4><p>当做了更改之后，</p><p>点击左边第三个，源代码管理</p><p>点击更改栏目下的test_vscode.md右边的加号，将其放到暂存的更改中</p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924173240036.png"></p><h4 id="提交-1"><a href="#提交-1" class="headerlink" title="提交"></a>提交</h4><p>点击源代码管理右侧的对号，并在弹出的对话框填入提交消息</p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924173517226.png"></p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924173606680.png"></p><h4 id="推送-1"><a href="#推送-1" class="headerlink" title="推送"></a>推送</h4><p>核对本地分支及远程库之后，在如下界面点击推送即可</p><p><img src="https://cdn.jsdelivr.net/gh/cumark/picBed/image-20210924173740184.png"></p><p>参考链接：</p><p><a href="https://git-scm.com/doc">https://git-scm.com/doc</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 代码托管 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 430. Flatten a Multilevel Doubly Linked List 扁平化多级双向链表</title>
      <link href="posts/345fb18b.html"/>
      <url>posts/345fb18b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below.</p><p>Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.</p><p><strong>Example 1:</strong></p><pre class="line-numbers language-none"><code class="language-none">Input: head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]Output: [1,2,3,7,8,11,12,9,10,4,5,6]ExplanationThe multilevel linked list in the input is as follows:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/cumark/picBed/master/multilevellinkedlist.png"></p><p>After flattening the multilevel linked list it becomes:</p><p><img src="https://raw.githubusercontent.com/cumark/picBed/master/multilevellinkedlistflattened.png"></p><p><strong>Example 2:</strong></p><pre class="line-numbers language-none"><code class="language-none">Input: head = [1,2,null,3]Output: [1,3,2]Explanation:The input multilevel linked list is as follows:  1---2---NULL  |  3---NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Example 3:</strong></p><pre class="line-numbers language-none"><code class="language-none">Input: head = []Output: []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>How multilevel linked list is represented in test case:</strong></p><p>We use the multilevel linked list from <strong>Example 1</strong> above:</p><pre class="line-numbers language-none"><code class="language-none">1---2---3---4---5---6--NULL        |        7---8---9---10--NULL            |            11--12--NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>The serialization of each level is as follows:</p><pre class="line-numbers language-none"><code class="language-none">[1,2,3,4,5,6,null][7,8,9,10,null][11,12,null]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>To serialize all levels together we will add nulls in each level to signify no node connects to the upper node of the previous level. The serialization becomes:</p><pre class="line-numbers language-none"><code class="language-none">[1,2,3,4,5,6,null][null,null,7,8,9,10,null][null,11,12,null]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Merging the serialization of each level and removing trailing nulls we obtain:</p><pre class="line-numbers language-none"><code class="language-none">[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>Constraints:</strong></p><ul><li>The number of Nodes will not exceed <code>1000</code>.</li><li><code>1 &lt;= Node.val &lt;= 10^5</code></li></ul><p>分析：这道题给出一个多级双向链表，要求将其扁平化，也就是将多级转变为单极，这种形式与二叉树链表的先序遍历非常相似，因此优先考虑深度优先搜索遍历</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>从head开始遍历链表，当遇到存在child节点时，则保存node.next，然后dfs node.child（与二叉树先序优先搜索遍历相似），将node.next与node.child构建先后续关系，node.child置于null。dfs最终得到child节点的尾节点，将尾节点和之前保存的node.next构建先后续关系，dfs深层遍历后回溯到之前的层，把每一层child节点的前后构建完成。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">*</span><span class="token comment">// Definition for a Node.</span><span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> val<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> prev<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> child<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token operator">/</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Node</span> cur<span class="token operator">=</span>node<span class="token punctuation">;</span>        <span class="token class-name">Node</span> last<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Node</span> next<span class="token operator">=</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>child<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">Node</span> childLast<span class="token operator">=</span><span class="token function">dfs</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>                next<span class="token operator">=</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                cur<span class="token punctuation">.</span>next<span class="token operator">=</span>cur<span class="token punctuation">.</span>child<span class="token punctuation">;</span>                cur<span class="token punctuation">.</span>child<span class="token punctuation">.</span>prev<span class="token operator">=</span>cur<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>next<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    childLast<span class="token punctuation">.</span>next<span class="token operator">=</span>next<span class="token punctuation">;</span>                    next<span class="token punctuation">.</span>prev<span class="token operator">=</span>childLast<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                cur<span class="token punctuation">.</span>child<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>                last<span class="token operator">=</span>childLast<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                last<span class="token operator">=</span>cur<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur<span class="token operator">=</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> last<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 58. Length of Last Word 最后一个单词的长度</title>
      <link href="posts/776c8164.html"/>
      <url>posts/776c8164.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Given a string <code>s</code> consisting of some words separated by some number of spaces, return <em>the length of the <strong>last</strong> word in the string.</em></p><p>A <strong>word</strong> is a maximal substring consisting of non-space characters only.</p><p><strong>Example 1:</strong></p><pre class="line-numbers language-none"><code class="language-none">Input: s = "Hello World"Output: 5Explanation: The last word is "World" with length 5.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Example 2:</strong></p><pre class="line-numbers language-none"><code class="language-none">Input: s = "   fly me   to   the moon  "Output: 4Explanation: The last word is "moon" with length 4.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Example 3:</strong></p><pre class="line-numbers language-none"><code class="language-none">Input: s = "luffy is still joyboy"Output: 6Explanation: The last word is "joyboy" with length 6.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> consists of only English letters and spaces <code>' '</code>.</li><li>There will be at least one word in <code>s</code>.</li></ul><p>分析：这道题求一个句子之中最后一个单词的长度，最简单的方法就是判断是不是为空格，是空格就把sum置0，否则累加，最终得到的就是最后一个单词的长度</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>遇到空格就把sum置0，否则累加，最终得到最后一个单词的长度</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLastWord</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> ch<span class="token operator">:</span>s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ch<span class="token operator">!=</span><span class="token string">' '</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                sum<span class="token operator">++</span><span class="token punctuation">;</span>                ans<span class="token operator">=</span>sum<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 673. Number of Longest Increasing Subsequence 最长递增子序列的个数</title>
      <link href="posts/e88ed89b.html"/>
      <url>posts/e88ed89b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Given an integer array <code>nums</code>, return <em>the number of longest increasing subsequences.</em></p><p><strong>Notice</strong> that the sequence has to be <strong>strictly</strong> increasing.</p><p><strong>Example 1:</strong></p><pre class="line-numbers language-none"><code class="language-none">Input: nums = [1,3,5,4,7]Output: 2Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Example 2:</strong></p><pre class="line-numbers language-none"><code class="language-none">Input: nums = [2,2,2,2,2]Output: 5Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2000</code></li><li><code>-10^6 &lt;= nums[i] &lt;= 10^6</code></li></ul><p>分析：这道题给出一个数组，要求求出最长的递增的子序列的总数，这里有两个限定词，最长和递增。题目为求总数，可以用动态规划方法，限定词为最长，可以设置为一个dp数组，递增放到循环里进行判断，故设置len[i]表示结尾为nums[i]的最长子序列的长度，cnt[i]表示结尾为nums[i]的最长子序列的数量。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>对于数组中或中的每个元素，它们都带有三个字段：<br>1）最大增加/减少长度以当前元素结束，<br>2）它自己的值，<br>3）最大长度的总数，<br>并且每次我们访问一个元素时，我们都会使用它来更新1和 3<br>设置len[i]表示结尾为nums[i]的最长子序列的长度，cnt[i]表示结尾为nums[i]的最长子序列的数量。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findNumberOfLIS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n<span class="token operator">=</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> max<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> len<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//长度</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cnt<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//个数</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            len<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>cnt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>len<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        cnt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>cnt<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>len<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        len<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>len<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                        cnt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>cnt<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment">//求最大递增子序列的数量</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>max<span class="token operator">==</span>len<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ans<span class="token operator">+=</span>cnt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>max<span class="token operator">&lt;</span>len<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ans<span class="token operator">=</span>cnt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                max<span class="token operator">=</span>len<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 650. 2 Keys Keyboard 只有两个键的键盘</title>
      <link href="posts/c4b7fa82.html"/>
      <url>posts/c4b7fa82.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p>There is only one character <code>'A'</code> on the screen of a notepad. You can perform two operations on this notepad for each step:</p><ul><li>Copy All: You can copy all the characters present on the screen (a partial copy is not allowed).</li><li>Paste: You can paste the characters which are copied last time.</li></ul><p>Given an integer <code>n</code>, return <em>the minimum number of operations to get the character</em> <code>'A'</code> <em>exactly</em> <code>n</code> <em>times on the screen</em>.</p></li></ul><p>  <strong>Example 1:</strong></p>  <pre class="line-numbers language-none"><code class="language-none">Input: n = 3Output: 3Explanation: Intitally, we have one character 'A'.In step 1, we use Copy All operation.In step 2, we use Paste operation to get 'AA'.In step 3, we use Paste operation to get 'AAA'.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  <strong>Example 2:</strong></p>  <pre class="line-numbers language-none"><code class="language-none">Input: n = 1Output: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li></ul><p>分析：这道题主要说，如果要从A获得AA，需要2个额外的步骤（全部复制然后粘贴），如果要从A获得AAA，我们需要三个额外的步骤，（全部复制，然后粘贴，再次粘贴）。为了生成 AAAA，我们需要 AA 的 2 个步骤。<br>但是，要获得 AAAAAAAA，最好的方法是从 AAAA 获得，有 2 个步骤（全部复制然后粘贴）<br>本质上，我们找到了下一个更短的序列，它可以被复制然后多次粘贴以生成所需的序列。当我们找到一个可以完美分割我们所需序列长度的长度时，我们就不需要检查任何更短的序列。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>看到字符串相关，最容易想到的便是动态规划，动态规划方程经验证可写为，dp[i]=dp[j]+i/j，其中dp[i]是目前得到记事本相应字符个数所需的最少操作次数，dp[j]为之前（最终匹配到的为i的约数）。如i=9，j=3，那么经此动态规划方程运算，则dp[i]会在dp[j]的基础上加3，相当于复制，粘贴，粘贴。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minSteps</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span>j<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>i<span class="token operator">/</span>j<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 326. Power of Three 3的幂</title>
      <link href="posts/3e4049d7.html"/>
      <url>posts/3e4049d7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of three. Otherwise, return <code>false</code></em>.</p><p>An integer <code>n</code> is a power of three, if there exists an integer <code>x</code> such that <code>n == 3x</code>.</p><p><strong>Example 1:</strong></p><pre class="line-numbers language-none"><code class="language-none">Input: n = 27Output: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Example 2:</strong></p><pre class="line-numbers language-none"><code class="language-none">Input: n = 0Output: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Example 3:</strong></p><pre class="line-numbers language-none"><code class="language-none">Input: n = 9Output: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Example 4:</strong></p><pre class="line-numbers language-none"><code class="language-none">Input: n = 45Output: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Constraints:</strong></p><ul><li><code>-2^31 &lt;= n &lt;= 2^31 - 1</code></li></ul><h3 id="分析：这道题要判断n是否是3的幂"><a href="#分析：这道题要判断n是否是3的幂" class="headerlink" title="分析：这道题要判断n是否是3的幂"></a>分析：这道题要判断n是否是3的幂</h3><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>最容易想到的思路是，用n不断除3，如果能除到1且无余数则为3的幂，否则不是。整个过程的时间复杂度为log(n)，时间复杂度为log(1)</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPowerOfThree</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">!=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>n<span class="token operator">%</span><span class="token number">3</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            n<span class="token operator">/=</span><span class="token number">3</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>在int可表示的范围内，3的最大幂为3的19次幂，这个数字仅是3的幂数的公倍数，所以可以从n是否3的19次幂的约数来判断。这个过程仅做了常数级运算，时间复杂度为log(1)，空间复杂度为log(1)</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-none"><code class="language-none">class Solution {    public boolean isPowerOfThree(int n) {        int max=(int)Math.pow(3,19);        if(n&gt;0&amp;&amp;max%n==0) {            return true;        }        return false;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 725. Split Linked List in Parts 分隔链表</title>
      <link href="posts/b75f9389.html"/>
      <url>posts/b75f9389.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>Given the <code>head</code> of a singly linked list and an integer <code>k</code>, split the linked list into <code>k</code> consecutive linked list parts.</p><p>The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.</p><p>The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.</p><p>Return <em>an array of the</em> <code>k</code> <em>parts</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/06/13/split1-lc.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">Input: head = [1,2,3], k = 5Output: [[1],[2],[3],[],[]]Explanation:The first element output[0] has output[0].val = 1, output[0].next = null.The last element output[4] is null, but its string representation as a ListNode is [].<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/06/13/split2-lc.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3Output: [[1,2,3,4],[5,6,7],[8,9,10]]Explanation:The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the list is in the range <code>[0, 1000]</code>.</li><li><code>0 &lt;= Node.val &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= 50</code></li></ul><p>这道题要把一个ListNode链表，平均分隔为k段，有部分数量可能多一个，放到前面。对于一道 Medium 题而言，思路比较清晰，主要就是考察了一个对链表的使用和对细节的把握，可以使用两个for循环，把被分割的每一段链表的开端设为上一段的next，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>cur<span class="token punctuation">;</span><span class="token keyword">int</span> part<span class="token operator">=</span>every<span class="token operator">+</span><span class="token punctuation">(</span>suff<span class="token operator">&gt;</span>i<span class="token operator">?</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于每一段链表的结尾，则采用如下方式，让末尾的后置设为null</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ListNode</span> next<span class="token operator">=</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>cur<span class="token punctuation">.</span>next<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>cur<span class="token operator">=</span>next<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后比较这个距离和，跟总距离减去该距离所得结果之间的较小值返回即可，参见代码如下：</p><p>解法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">ListNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">splitListToParts</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token class-name">ListNode</span> cur<span class="token operator">=</span>head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum<span class="token operator">++</span><span class="token punctuation">;</span>            head<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> suff<span class="token operator">=</span>sum<span class="token operator">%</span>k<span class="token punctuation">;</span><span class="token keyword">int</span> every<span class="token operator">=</span>sum<span class="token operator">/</span>k<span class="token punctuation">;</span>        <span class="token class-name">ListNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>k<span class="token operator">&amp;&amp;</span>cur<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>cur<span class="token punctuation">;</span>            <span class="token keyword">int</span> part<span class="token operator">=</span>every<span class="token operator">+</span><span class="token punctuation">(</span>suff<span class="token operator">&gt;</span>i<span class="token operator">?</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>part<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                cur<span class="token operator">=</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token class-name">ListNode</span> next<span class="token operator">=</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur<span class="token punctuation">.</span>next<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>            cur<span class="token operator">=</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
