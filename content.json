{"meta":{"title":"Mark","subtitle":"Markの博客","description":"硕士研究生 | 计算机技术 | 软件开发","author":"Mark","url":"http://www.liniuniu.top","root":"/"},"pages":[{"title":"","date":"2021-09-22T08:04:15.502Z","updated":"2021-09-22T08:04:15.502Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"http://www.liniuniu.top/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-22T08:04:15.434Z","comments":true,"path":"404.html","permalink":"http://www.liniuniu.top/404.html","excerpt":"","text":""},{"title":"","date":"2021-09-22T08:04:15.503Z","updated":"2021-09-22T08:04:15.503Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"http://www.liniuniu.top/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-22T08:04:15.441Z","comments":true,"path":"List/index.html","permalink":"http://www.liniuniu.top/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-22T08:04:15.501Z","comments":true,"path":"archives/index.html","permalink":"http://www.liniuniu.top/archives/index.html","excerpt":"","text":""},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-22T08:04:15.501Z","comments":true,"path":"about/index.html","permalink":"http://www.liniuniu.top/about/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-09-22T09:01:00.000Z","updated":"2021-09-22T09:01:56.551Z","comments":true,"path":"contact/index.html","permalink":"http://www.liniuniu.top/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Markの友链信息 博客名称: Markの博客 博客网址: http://www.liniuniu.top 博客头像: https://z3.ax1x.com/2021/09/22/4UQnjP.jpg 博客介绍: Experience is the father of wisdom and memory the mother"},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-22T08:04:15.502Z","comments":true,"path":"categories/index.html","permalink":"http://www.liniuniu.top/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-09-22T08:04:15.502Z","comments":true,"path":"census/index.html","permalink":"http://www.liniuniu.top/census/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-22T08:04:15.503Z","comments":true,"path":"resource/index.html","permalink":"http://www.liniuniu.top/resource/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-09-22T08:04:15.503Z","comments":true,"path":"friends/index.html","permalink":"http://www.liniuniu.top/friends/index.html","excerpt":"","text":""},{"title":"资源","date":"2020-02-10T14:07:08.000Z","updated":"2021-09-22T02:41:18.956Z","comments":false,"path":"resources/index.html","permalink":"http://www.liniuniu.top/resources/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-22T08:04:15.503Z","comments":true,"path":"tags/index.html","permalink":"http://www.liniuniu.top/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-09-22T12:33:48.515Z","updated":"2021-09-22T08:04:15.438Z","comments":true,"path":"List/galleries/index.html","permalink":"http://www.liniuniu.top/List/galleries/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-22T08:04:15.442Z","comments":true,"path":"List/tools/index.html","permalink":"http://www.liniuniu.top/List/tools/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-22T08:04:15.441Z","comments":true,"path":"List/music/index.html","permalink":"http://www.liniuniu.top/List/music/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-22T08:04:15.441Z","comments":true,"path":"List/movies/index.html","permalink":"http://www.liniuniu.top/List/movies/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-09-22T12:33:00.851Z","updated":"2021-09-22T08:04:15.438Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-09-22T12:33:35.648Z","updated":"2021-09-22T08:04:15.439Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-09-22T08:04:15.439Z","updated":"2021-09-22T08:04:15.439Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-09-22T08:04:15.440Z","updated":"2021-09-22T08:04:15.440Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-09-22T08:04:15.439Z","updated":"2021-09-22T08:04:15.439Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-09-22T08:04:15.439Z","updated":"2021-09-22T08:04:15.439Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-09-22T08:04:15.440Z","updated":"2021-09-22T08:04:15.440Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-09-22T08:04:15.440Z","updated":"2021-09-22T08:04:15.440Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-09-22T08:04:15.440Z","updated":"2021-09-22T08:04:15.440Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-09-22T08:04:15.440Z","updated":"2021-09-22T08:04:15.440Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-09-22T08:04:15.441Z","updated":"2021-09-22T08:04:15.441Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-09-22T08:04:15.441Z","updated":"2021-09-22T08:04:15.441Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""}],"posts":[{"title":"37. Sudoku Solver 解数独","slug":"Leetcode37","date":"2021-09-28T06:13:00.000Z","updated":"2021-09-28T12:45:10.034Z","comments":true,"path":"posts/a7061b21.html","link":"","permalink":"http://www.liniuniu.top/posts/a7061b21.html","excerpt":"","text":"Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. The '.' character indicates empty cells. Example 1: Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] Output: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]] Explanation: The input board is shown above and the only valid solution is shown below: Constraints: board.length == 9 board[i].length == 9 board[i][j] is a digit or '.'. It is guaranteed that the input board has only one solution. 分析这道题要求解9*9数组数独，可以采用递归回溯法，分为主函数和回溯函数和验证函数， 主函数：传递到回溯函数 回溯函数：遍历数组数独，递归验证是否符合数独标准，若不符合则回溯至上一层，直到全部符合数独标准为止。 验证函数：只验证新改变的坐标是否符合数独 方法使用递归回溯的方法，不断验证，直到出现符合全部数独标准的一组结果。 代码class Solution { public void solveSudoku(char[][] board) { solve(board); } public boolean solve(char[][] board) { for(int i=0;i&lt;board.length;i++) { for(int j=0;j&lt;board[0].length;j++) { if(board[i][j]=='.') { for(char ch='1';ch&lt;='9';ch++) { if(isValid(board,i,j,ch)) { board[i][j]=ch; if(solve(board)) { return true; } else { board[i][j]='.'; } } } return false; } } } return true; } public boolean isValid(char[][] board,int i,int j,char ch) { for(int index=0;index&lt;9;index++) { if(board[index][j]!='.'&amp;&amp;board[index][j]==ch) return false; if(board[i][index]!='.'&amp;&amp;board[i][index]==ch) return false; if(board[3*(i/3)+index/3][3*(j/3)+index%3]!='.'&amp;&amp;board[3*(i/3)+index/3][3*(j/3)+index%3]==ch) return false; } return true; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"},{"name":"dfs","slug":"dfs","permalink":"http://www.liniuniu.top/tags/dfs/"},{"name":"backtrace","slug":"backtrace","permalink":"http://www.liniuniu.top/tags/backtrace/"}],"author":"Mark"},{"title":"36. Valid Sudoku 有效的数独","slug":"Leetcode36","date":"2021-09-28T06:00:00.000Z","updated":"2021-09-28T12:45:10.028Z","comments":true,"path":"posts/5cf1e14c.html","link":"","permalink":"http://www.liniuniu.top/posts/5cf1e14c.html","excerpt":"","text":"Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. Example 1: Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] Output: true Example 2: Input: board = [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid. Constraints: board.length == 9 board[i].length == 9 board[i][j] is a digit 1-9 or '.'. 分析这道题要求验证当前状态下的9*9数组是否为有效的数独，难点在于对9宫格之中3*3方格的验证，这里可以采用board[(i/3)*3+j/3][(i%3)*3+j%3]的方式进行表示，遍历即可 方法遍历9*9数组，若不出现重复，则返回true 代码class Solution { public boolean isValidSudoku(char[][] board) { for(int i=0;i&lt;9;i++) { Set&lt;Character&gt; set=new HashSet(); for(int j=0;j&lt;9;j++) { if(!set.contains(board[i][j])&amp;&amp;board[i][j]!='.') { set.add(board[i][j]); } else if(board[i][j]!='.'){ return false; } } set=new HashSet(); for(int j=0;j&lt;9;j++) { if(!set.contains(board[j][i])&amp;&amp;board[j][i]!='.') { set.add(board[j][i]); } else if(board[j][i]!='.'){ return false; } } set=new HashSet(); for(int j=0;j&lt;9;j++) { if(!set.contains(board[(i/3)*3+j/3][(i%3)*3+j%3])&amp;&amp;board[(i/3)*3+j/3][(i%3)*3+j%3]!='.') { set.add(board[(i/3)*3+j/3][(i%3)*3+j%3]); } else if(board[(i/3)*3+j/3][(i%3)*3+j%3]!='.'){ return false; } } } return true; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"},{"title":"Leetcode 130. Surrounded Regions 被围绕的区域","slug":"Leetcode130","date":"2021-09-28T05:42:00.000Z","updated":"2021-09-28T12:45:10.011Z","comments":true,"path":"posts/372ac7d5.html","link":"","permalink":"http://www.liniuniu.top/posts/372ac7d5.html","excerpt":"","text":"Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region. Example 1: Input: board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Output: [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Explanation: Surrounded regions should not be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically. Example 2: Input: board = [[\"X\"]] Output: [[\"X\"]] Constraints: m == board.length n == board[i].length 1 &lt;= m, n &lt;= 200 board[i][j] is 'X' or 'O'. 分析这道题要求边缘O及与边缘的O直接相连的O不做改变，其他的O全部改为X，那么可以仅dfs遍历矩阵的边缘，对于O，则进行dfs遍历，并将之置为M。最后再将所有M置为O，O置为X即可。 方法采用dfs，遍历矩阵边缘，最后再遍历整个矩阵，将所作的标记更新 代码class Solution { public void solve(char[][] board) { if(board.length&lt;1||board[0].length&lt;1) { return ; } for(int i=0;i&lt;board.length;i++) { dfs(board,i,0); dfs(board,i,board[0].length-1); } for(int i=0;i&lt;board[0].length;i++) { dfs(board,0,i); dfs(board,board.length-1,i); } for(int i=0;i&lt;board.length;i++) { for(int j=0;j&lt;board[0].length;j++) { if(board[i][j]=='M') { board[i][j]='O'; } else { board[i][j]='X'; } } } } public void dfs(char[][] board,int i,int j) { if(i&lt;0||i&gt;=board.length||j&lt;0||j&gt;=board[0].length||board[i][j]!='O') { return ; } board[i][j]='M'; dfs(board,i+1,j); dfs(board,i,j+1); dfs(board,i-1,j); dfs(board,i,j-1); } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"},{"name":"dfs","slug":"dfs","permalink":"http://www.liniuniu.top/tags/dfs/"}],"author":"Mark"},{"title":"Leetcode 208. Implement Trie (Prefix Tree) 实现Trie（前缀树）","slug":"Leetcode208","date":"2021-09-28T05:30:00.000Z","updated":"2021-09-28T13:02:32.721Z","comments":true,"path":"posts/756a1399.html","link":"","permalink":"http://www.liniuniu.top/posts/756a1399.html","excerpt":"","text":"A trie (pronounced as “try”) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the Trie class: Trie() Initializes the trie object. void insert(String word) Inserts the string word into the trie. boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise. boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise. Example 1: Input [\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"] [[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]] Output [null, null, true, false, true, null, true] Explanation Trie trie = new Trie(); trie.insert(\"apple\"); trie.search(\"apple\"); // return True trie.search(\"app\"); // return False trie.startsWith(\"app\"); // return True trie.insert(\"app\"); trie.search(\"app\"); // return True Constraints: 1 &lt;= word.length, prefix.length &lt;= 2000 word and prefix consist only of lowercase English letters. At most 3 * 104 calls in total will be made to insert, search, and startsWith. 分析这道题要求设计一个Trie数的类，首先需定义一个节点，TrieNode节点应该包括如下部分： 1.包含TrieNode节点值 2.包含是否完整词汇的判断 3.包含TrieNode节点的子节点，其中应该包括26个英文字母 4.包含创建TrieNode的方法，具体有TrieNode()空函数值，及赋node节点值的方法 设计TrieNode节点后，可以设置一个root空节点，当insert时，则插入于root空节点之后 方法设计TrieNode节点，当insert时，则插入字典树所不存在的字符，并在插入完之后，将isWord置为true。 当search时，从root节点，遍历字典树。 代码class TrieNode { public char val; public boolean isWord=false; public TrieNode[] children=new TrieNode[26]; public TrieNode(){} TrieNode(char c) { TrieNode node=new TrieNode(); node.val=c; } } class Trie { public TrieNode root; public Trie() { root=new TrieNode(); root.val=' '; } public void insert(String word) { TrieNode node=root; for(int i=0;i&lt;word.length();i++) { char ch=word.charAt(i); if(node.children[ch-'a']==null) { node.children[ch-'a']=new TrieNode(ch); } node=node.children[ch-'a']; } node.isWord=true; } public boolean search(String word) { TrieNode node=root; for(char ch:word.toCharArray()) { if(node.children[ch-'a']!=null) { node=node.children[ch-'a']; } else { return false; } } return node.isWord; } public boolean startsWith(String prefix) { TrieNode node=root; for(char ch:prefix.toCharArray()) { if(node.children[ch-'a']!=null) { node=node.children[ch-'a']; } else { return false; } } return true; } } /** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"},{"title":"Leetcode 410. Split Array Largest Sum 分割数组的最大值","slug":"Leetcode410","date":"2021-09-28T05:15:00.000Z","updated":"2021-09-28T12:45:10.061Z","comments":true,"path":"posts/af957438.html","link":"","permalink":"http://www.liniuniu.top/posts/af957438.html","excerpt":"","text":"Given an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays. Example 1: Input: nums = [7,2,5,10,8], m = 2 Output: 18 Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18. Example 2: Input: nums = [1,2,3,4,5], m = 2 Output: 9 Example 3: Input: nums = [1,4,4], m = 3 Output: 4 Constraints: 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 106 1 &lt;= m &lt;= min(50, nums.length) 分析这道题要求这m个子数组各自和的最大值最小，应对数组问题，可以考虑二分搜索，首先要确定上下界。由于各自和的最大值会在max（nums[i]）和sum之间，可以以max为左边界，sum为右边界，利用二分搜索不断接近并得到答案。 在分割时，采用mid=（l+r）/2要确保数字总和足够大，而又小于结果之间。 我们会得到两种结果： 1.我们可以将数组分成m个以上子数列，这样，意味着我们的中间值太小，因此可以将l=mid+1; 2.不可以分成m个数列，这样说明中间值过大，可以将r=mid-1; 方法采用二分搜索的方法，不断遍历，直至左右边界相遇 代码class Solution { public int splitArray(int[] nums, int m) { int max=0;long sum=0; for(int num:nums) { max=Math.max(max,num); sum+=num; } if(m==1) return (int)sum; long l=max;long r=sum; while(l&lt;=r) { long mid=(l+r)/2; if(valid(mid,nums,m)) { r=mid-1; } else { l=mid+1; } } return (int)l; } public boolean valid(long target,int[] nums,int m) { int count=1; long total=0; for(int num:nums) { total+=num; if(total&gt;target) { total=num; count++; if(count&gt;m) { return false; } } } return true; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"},{"name":"binarySearch","slug":"binarySearch","permalink":"http://www.liniuniu.top/tags/binarySearch/"}],"author":"Mark"},{"title":"639. Decode Ways 解码方法 II","slug":"Leetcode639","date":"2021-09-27T12:35:00.000Z","updated":"2021-09-28T12:45:10.114Z","comments":true,"path":"posts/1b13e86b.html","link":"","permalink":"http://www.liniuniu.top/posts/1b13e86b.html","excerpt":"","text":"A message containing letters from A-Z can be encoded into numbers using the following mapping: 'A' -&gt; \"1\" 'B' -&gt; \"2\" ... 'Z' -&gt; \"26\" To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into: \"AAJF\" with the grouping (1 1 10 6) \"KJF\" with the grouping (11 10 6) Note that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\". In addition to the mapping above, an encoded message may contain the '*' character, which can represent any digit from '1' to '9' ('0' is excluded). For example, the encoded message \"1*\" may represent any of the encoded messages \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", or \"19\". Decoding \"1*\" is equivalent to decoding any of the encoded messages it can represent. Given a string s consisting of digits and '*' characters, return the number of ways to decode it. Since the answer may be very large, return it modulo 109 + 7. Example 1: Input: s = \"*\" Output: 9 Explanation: The encoded message can represent any of the encoded messages \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", or \"9\". Each of these can be decoded to the strings \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", and \"I\" respectively. Hence, there are a total of 9 ways to decode \"*\". Example 2: Input: s = \"1*\" Output: 18 Explanation: The encoded message can represent any of the encoded messages \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", or \"19\". Each of these encoded messages have 2 ways to be decoded (e.g. \"11\" can be decoded to \"AA\" or \"K\"). Hence, there are a total of 9 * 2 = 18 ways to decode \"1*\". Example 3: Input: s = \"2*\" Output: 15 Explanation: The encoded message can represent any of the encoded messages \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", or \"29\". \"21\", \"22\", \"23\", \"24\", \"25\", and \"26\" have 2 ways of being decoded, but \"27\", \"28\", and \"29\" only have 1 way. Hence, there are a total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode \"2*\". Constraints: 1 &lt;= s.length &lt;= 105 s[i] is a digit or '*'. 分析字符串问题，优先考虑动态规划的方法。因数值比较大，设置long[] dp，分析dp[i]和dp[i-1]与dp[i-2]之间的关系，有以下几种情况： For dp[i-1]: / \\ / \\ s[i-1]='*' s[i-1]&gt;0 | | + 9*dp[i-1] + dp[i-1] For dp[i-2]: / \\ / \\ s[n-2]='1'||'2' s[n-2]='*' / \\ / \\ s[n-1]='*' s[n-1]!='*' s[n-1]='*' s[n-1]!='*' / \\ | | / \\ s[n-2]='1' s[n-2]='2' num(i-2,i-1)&lt;=26 | s[n-1]&lt;=6 s[n-1]&gt;6 | | | | | | + 9*dp[i-2] + 6*dp[i-2] + dp[i-2] + 15*dp[i-2] + 2*dp[i-2] + dp[i-2] 具体可以设置相关条件，将dp[i]与dp[i-1]和dp[i-2]累加 方法运用动态规划方法，与爬楼梯问题类似，但情况较复杂，设置条件累加即可。由于数值较大，每一次遍历时，更新dp[i]取余的数值，以免溢出。 代码class Solution { public int numDecodings(String s) { long[] dp=new long[s.length()+1]; dp[0]=1; if(s.charAt(0)=='0') { return 0; } dp[1]=(s.charAt(0)=='*')?9:1; for(int i=2;i&lt;=s.length();i++) { if(s.charAt(i-1)=='*') { dp[i]+=dp[i-1]*9; } else if(s.charAt(i-1)&gt;'0') { dp[i]+=dp[i-1]; } if(s.charAt(i-2)=='*') { if(s.charAt(i-1)=='*') { dp[i]+=dp[i-2]*15; } else if(s.charAt(i-1)&lt;='6'){ dp[i]+=dp[i-2]*2; } else { dp[i]+=dp[i-2]; } } else if(s.charAt(i-2)=='1'){ if(s.charAt(i-1)=='*') { dp[i]+=dp[i-2]*9; } else { dp[i]+=dp[i-2]; } } else if(s.charAt(i-2)=='2'){ if(s.charAt(i-1)=='*') { dp[i]+=dp[i-2]*6; } else if(s.charAt(i-1)&lt;='6'){ dp[i]+=dp[i-2]; } } dp[i]=dp[i]%1000000007; } return (int)(dp[s.length()]); } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"},{"name":"dp","slug":"dp","permalink":"http://www.liniuniu.top/tags/dp/"}],"author":"Mark"},{"title":"5. Longest Palindromic Substring 最长回文子串","slug":"Leetcode5","date":"2021-09-27T12:20:00.000Z","updated":"2021-09-28T12:45:10.079Z","comments":true,"path":"posts/b707e9b2.html","link":"","permalink":"http://www.liniuniu.top/posts/b707e9b2.html","excerpt":"","text":"Given a string s, return the longest palindromic substring in s. Example 1: Input: s = \"babad\" Output: \"bab\" Note: \"aba\" is also a valid answer. Example 2: Input: s = \"cbbd\" Output: \"bb\" Example 3: Input: s = \"a\" Output: \"a\" Example 4: Input: s = \"ac\" Output: \"a\" Constraints: 1 &lt;= s.length &lt;= 1000 s consist of only digits and English letters. 分析字符串问题，优先考虑动态规划的方法。设置boolean[][] dp，在遍历时有如下几种情况 当s.charAt(i)==s.charAt(j)时，这时dp[i][j]=dp[i-1][j+1] 当i-j&lt;3时，这时dp[i][j]=dp[i-1][j+1] 这时会产生一个新的问题，就是需要先遍历以j，i为边界的区间之内明确的boolean判定值，那么采取i正向遍历，j以i为起点逆向遍历，是一个比较好的方式 如果dp[i][j]为true并且当前i-j+1&gt;所存结果的长度时，用string.substring来更新所存结果 方法运用动态规划方法，动态规划方程为，当s.charAt(i)==s.charAt(j)时，这时dp[i][j]=dp[i-1][j+1]，当i-j&lt;3时，这时dp[i][j]=dp[i-1][j+1]，并不断更新最长的子串 代码class Solution { public String longestPalindrome(String s) { int n=s.length();String ans=\"\"; boolean[][] dp=new boolean[n][n]; for(int i=0;i&lt;n;i++) { for(int j=i;j&gt;=0;j--) { if(s.charAt(i)==s.charAt(j)) dp[i][j]=(i-j&lt;3||dp[i-1][j+1]); if(dp[i][j]&amp;&amp;i-j+1&gt;ans.length()) { ans=s.substring(j,i+1); } } } return ans; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"},{"name":"dp","slug":"dp","permalink":"http://www.liniuniu.top/tags/dp/"}],"author":"Mark"},{"title":"151. Reverse Words in a String 翻转字符串里的单词","slug":"Leetcode151","date":"2021-09-27T12:05:00.000Z","updated":"2021-09-28T12:45:10.016Z","comments":true,"path":"posts/a17663d9.html","link":"","permalink":"http://www.liniuniu.top/posts/a17663d9.html","excerpt":"","text":"Given an input string s, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space. Return a string of the words in reverse order concatenated by a single space. Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces. Example 1: Input: s = \"the sky is blue\" Output: \"blue is sky the\" Example 2: Input: s = \" hello world \" Output: \"world hello\" Explanation: Your reversed string should not contain leading or trailing spaces. Example 3: Input: s = \"a good example\" Output: \"example good a\" Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string. Example 4: Input: s = \" Bob Loves Alice \" Output: \"Alice Loves Bob\" Example 5: Input: s = \"Alice does not even like bob\" Output: \"bob like even not does Alice\" Constraints: 1 &lt;= s.length &lt;= 104 s contains English letters (upper-case and lower-case), digits, and spaces ' '. There is at least one word in s. Follow-up: If the string data type is mutable in your language, can you solve it in-place with O(1) extra space? 分析1.String中前后可能有空格，可以使用s.trim()方法消除 2.单词前后可能有多个空格，可以使用s.split(“ +”)方法消除，其中空格表示间隔的字符，+表示一个及超过一个字符 3.需要反转单词顺序，应用Collections.reverse(list)的方法，将数组用Arrays.asList（）方法转化为list 4.当前已经求出一个已反转的list，可以应用String.join(“ “,list/array)的方法，在单词见加入空格并汇集成string 方法应用java本身的特性，消除string前后空格以及单词之间的空格，反转单词，再转化为string即可 代码public String reverseWords(String s) { String[] words = s.trim().split(\" +\"); Collections.reverse(Arrays.asList(words)); return String.join(\" \", words); }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"java","slug":"算法/java","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/java/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"},{"title":"541. Reverse String II 反转字符串 II","slug":"Leetcode541","date":"2021-09-27T11:53:00.000Z","updated":"2021-09-28T12:45:10.088Z","comments":true,"path":"posts/e834e913.html","link":"","permalink":"http://www.liniuniu.top/posts/e834e913.html","excerpt":"","text":"Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string. If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original. Example 1: Input: s = \"abcdefg\", k = 2 Output: \"bacdfeg\" Example 2: Input: s = \"abcd\", k = 2 Output: \"bacd\" Constraints: 1 &lt;= s.length &lt;= 104 s consists of only lowercase English letters. 1 &lt;= k &lt;= 104 分析1.每隔k个字符，则反转k个字符串，可以设置一个左端点i和右端点i+k-1 2.构建reverse函数，反转左端点和右端点之间的字符即可 方法设置左右端点，遍历并反转字符 代码class Solution { public String reverseStr(String s, int k) { char[] array=s.toCharArray(); for(int i=0;i&lt;s.length();) { int j=Math.min(i+k-1,s.length()-1); swap(i,j,array); i=i+2*k; } return String.valueOf(array); } public void swap(int i,int j,char[] array) { while(i&lt;j) { char temp=array[i]; array[i]=array[j]; array[j]=temp; i++;j--; } } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"},{"title":"56. Merge Intervals 合并区间","slug":"Leetcode56","date":"2021-09-27T11:49:00.000Z","updated":"2021-09-28T12:45:10.095Z","comments":true,"path":"posts/2ac753c1.html","link":"","permalink":"http://www.liniuniu.top/posts/2ac753c1.html","excerpt":"","text":"Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. Example 1: Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. Constraints: 1 &lt;= intervals.length &lt;= 104 intervals[i].length == 2 0 &lt;= starti &lt;= endi &lt;= 104 分析1.合并区间首先要确立左边界，应当对intervals数组以每个区间的左端点进行升序排序 2.然后将当前区间加入list之中，在list中与后续遍历区间的左端点进行对比 若大于等于左端点，则于遍历区间的右端点进行对比，确立右端点界限 若小于左端点，则确立遍历节点为当前节点 3.将list转换为数组，采用ans.toArray(new int[ans.size()][])的方式 方法初始化list存储结果区间，遍历区间，采取以上思想，返回不重叠区间数组 代码class Solution { public int[][] merge(int[][] intervals) { List&lt;int[]&gt; ans=new ArrayList(); if(intervals.length&lt;=1) { return intervals; } Arrays.sort(intervals,(i1,i2)-&gt;i1[0]-i2[0]); int[] cur=intervals[0]; ans.add(cur); for(int[] interval:intervals) { if(cur[1]&gt;=interval[0]) { cur[1]=Math.max(cur[1],interval[1]); } else { cur=interval; ans.add(cur); } } return ans.toArray(new int[ans.size()][]); } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"},{"title":"JAVA中HashMap，TreeMap,LinkedHashMap,Hashtable的应用和比较","slug":"4_Hash_comparation","date":"2021-09-27T10:54:00.000Z","updated":"2021-09-28T12:45:10.008Z","comments":true,"path":"posts/ac4e5e8d.html","link":"","permalink":"http://www.liniuniu.top/posts/ac4e5e8d.html","excerpt":"","text":"1.HashMap HashMap实现提供O（1）的查找和插入，键的顺序是任意的，由链表数组实现。 HashMap包含基于键（entry）的值 它只包含又一个空键和多个空值 它不维持秩序 部分底层源码： public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable { private static final long serialVersionUID = 362498820763181265L; static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 /** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * The load factor used when none specified in constructor. */ static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */ static final int TREEIFY_THRESHOLD = 8; /** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */ static final int UNTREEIFY_THRESHOLD = 6; /** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. */ static final int MIN_TREEIFY_CAPACITY = 64; /** * Basic hash bin node, used for most entries. (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) */ static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + \"=\" + value; } public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; } return false; } } 2.TreeMap TreeMap提供O(logN)的查找和插入 键是有序的，可以按照排序的顺序遍历，按照升序 TreeMap底层由红黑树实现 和HashMap一样，只包含独一的元素 不能有空键，但可以有多个空值 部分底层源码： public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable { /** * The comparator used to maintain order in this tree map, or * null if it uses the natural ordering of its keys. * * @serial */ private final Comparator&lt;? super K&gt; comparator; private transient Entry&lt;K,V&gt; root; /** * The number of entries in the tree */ private transient int size = 0; /** * The number of structural modifications to the tree. */ private transient int modCount = 0; /** * Constructs a new, empty tree map, using the natural ordering of its * keys. All keys inserted into the map must implement the {@link * Comparable} interface. Furthermore, all such keys must be * &lt;em&gt;mutually comparable&lt;/em&gt;: {@code k1.compareTo(k2)} must not throw * a {@code ClassCastException} for any keys {@code k1} and * {@code k2} in the map. If the user attempts to put a key into the * map that violates this constraint (for example, the user attempts to * put a string key into a map whose keys are integers), the * {@code put(Object key, Object value)} call will throw a * {@code ClassCastException}. */ public TreeMap() { comparator = null; } /** * Constructs a new, empty tree map, ordered according to the given * comparator. All keys inserted into the map must be &lt;em&gt;mutually * comparable&lt;/em&gt; by the given comparator: {@code comparator.compare(k1, * k2)} must not throw a {@code ClassCastException} for any keys * {@code k1} and {@code k2} in the map. If the user attempts to put * a key into the map that violates this constraint, the {@code put(Object * key, Object value)} call will throw a * {@code ClassCastException}. * * @param comparator the comparator that will be used to order this map. * If {@code null}, the {@linkplain Comparable natural * ordering} of the keys will be used. */ public TreeMap(Comparator&lt;? super K&gt; comparator) { this.comparator = comparator; } /** * Constructs a new tree map containing the same mappings as the given * map, ordered according to the &lt;em&gt;natural ordering&lt;/em&gt; of its keys. * All keys inserted into the new map must implement the {@link * Comparable} interface. Furthermore, all such keys must be * &lt;em&gt;mutually comparable&lt;/em&gt;: {@code k1.compareTo(k2)} must not throw * a {@code ClassCastException} for any keys {@code k1} and * {@code k2} in the map. This method runs in n*log(n) time. * * @param m the map whose mappings are to be placed in this map * @throws ClassCastException if the keys in m are not {@link Comparable}, * or are not mutually comparable * @throws NullPointerException if the specified map is null */ public TreeMap(Map&lt;? extends K, ? extends V&gt; m) { comparator = null; putAll(m); } /** * Constructs a new tree map containing the same mappings and * using the same ordering as the specified sorted map. This * method runs in linear time. * * @param m the sorted map whose mappings are to be placed in this map, * and whose comparator is to be used to sort this map * @throws NullPointerException if the specified map is null */ public TreeMap(SortedMap&lt;K, ? extends V&gt; m) { comparator = m.comparator(); try { buildFromSorted(m.size(), m.entrySet().iterator(), null, null); } catch (java.io.IOException cannotHappen) { } catch (ClassNotFoundException cannotHappen) { } } // Query Operations /** * Returns the number of key-value mappings in this map. * * @return the number of key-value mappings in this map */ public int size() { return size; } /** * Returns {@code true} if this map contains a mapping for the specified * key. * * @param key key whose presence in this map is to be tested * @return {@code true} if this map contains a mapping for the * specified key * @throws ClassCastException if the specified key cannot be compared * with the keys currently in the map * @throws NullPointerException if the specified key is null * and this map uses natural ordering, or its comparator * does not permit null keys */ public boolean containsKey(Object key) { return getEntry(key) != null; } /** * Returns {@code true} if this map maps one or more keys to the * specified value. More formally, returns {@code true} if and only if * this map contains at least one mapping to a value {@code v} such * that {@code (value==null ? v==null : value.equals(v))}. This * operation will probably require time linear in the map size for * most implementations. * * @param value value whose presence in this map is to be tested * @return {@code true} if a mapping to {@code value} exists; * {@code false} otherwise * @since 1.2 */ public boolean containsValue(Object value) { for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e)) if (valEquals(value, e.value)) return true; return false; } /** * Returns the value to which the specified key is mapped, * or {@code null} if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * {@code k} to a value {@code v} such that {@code key} compares * equal to {@code k} according to the map's ordering, then this * method returns {@code v}; otherwise it returns {@code null}. * (There can be at most one such mapping.) * * &lt;p&gt;A return value of {@code null} does not &lt;em&gt;necessarily&lt;/em&gt; * indicate that the map contains no mapping for the key; it's also * possible that the map explicitly maps the key to {@code null}. * The {@link #containsKey containsKey} operation may be used to * distinguish these two cases. * * @throws ClassCastException if the specified key cannot be compared * with the keys currently in the map * @throws NullPointerException if the specified key is null * and this map uses natural ordering, or its comparator * does not permit null keys */ public V get(Object key) { Entry&lt;K,V&gt; p = getEntry(key); return (p==null ? null : p.value); } public Comparator&lt;? super K&gt; comparator() { return comparator; } /** * @throws NoSuchElementException {@inheritDoc} */ public K firstKey() { return key(getFirstEntry()); } /** * @throws NoSuchElementException {@inheritDoc} */ public K lastKey() { return key(getLastEntry()); } 3.LinkedHashMap LinkedHashMap提供O(1)的查找和插入 键按照插入顺序排序，由双链桶实现 只包含独特的元素，可能由一个空键和多个空值 维持插入顺序 继承于HashMap，仅有维持插入顺序这一点与HashMap不同 部分源码： public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; { /* * Implementation note. A previous version of this class was * internally structured a little differently. Because superclass * HashMap now uses trees for some of its nodes, class * LinkedHashMap.Entry is now treated as intermediary node class * that can also be converted to tree form. The name of this * class, LinkedHashMap.Entry, is confusing in several ways in its * current context, but cannot be changed. Otherwise, even though * it is not exported outside this package, some existing source * code is known to have relied on a symbol resolution corner case * rule in calls to removeEldestEntry that suppressed compilation * errors due to ambiguous usages. So, we keep the name to * preserve unmodified compilability. * * The changes in node classes also require using two fields * (head, tail) rather than a pointer to a header node to maintain * the doubly-linked before/after list. This class also * previously used a different style of callback methods upon * access, insertion, and removal. */ /** * HashMap.Node subclass for normal LinkedHashMap entries. */ static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; { Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) { super(hash, key, value, next); } } private static final long serialVersionUID = 3801124242820219131L; /** * The head (eldest) of the doubly linked list. */ transient LinkedHashMap.Entry&lt;K,V&gt; head; /** * The tail (youngest) of the doubly linked list. */ transient LinkedHashMap.Entry&lt;K,V&gt; tail; /** * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt; * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order. * * @serial */ final boolean accessOrder; // internal utilities // link at the end of list private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) { LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else { p.before = last; last.after = p; } } // apply src's links to dst private void transferLinks(LinkedHashMap.Entry&lt;K,V&gt; src, LinkedHashMap.Entry&lt;K,V&gt; dst) { LinkedHashMap.Entry&lt;K,V&gt; b = dst.before = src.before; LinkedHashMap.Entry&lt;K,V&gt; a = dst.after = src.after; if (b == null) head = dst; else b.after = dst; if (a == null) tail = dst; else a.before = dst; } // overrides of HashMap hook methods void reinitialize() { super.reinitialize(); head = tail = null; } Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) { LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p; } Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) { LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p; LinkedHashMap.Entry&lt;K,V&gt; t = new LinkedHashMap.Entry&lt;K,V&gt;(q.hash, q.key, q.value, next); transferLinks(q, t); return t; } 4.HashTable HashTable只包含独特的元素 可能没有任何空键和值 它是同步的 它是一个遗留类 部分源码： public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable { /** * The hash table data. */ private transient Entry&lt;?,?&gt;[] table; /** * The total number of entries in the hash table. */ private transient int count; /** * The table is rehashed when its size exceeds this threshold. (The * value of this field is (int)(capacity * loadFactor).) * * @serial */ private int threshold; /** * The load factor for the hashtable. * * @serial */ private float loadFactor; /** * The number of times this Hashtable has been structurally modified * Structural modifications are those that change the number of entries in * the Hashtable or otherwise modify its internal structure (e.g., * rehash). This field is used to make iterators on Collection-views of * the Hashtable fail-fast. (See ConcurrentModificationException). */ private transient int modCount = 0; /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = 1421746759512286392L; /** * Constructs a new, empty hashtable with the specified initial * capacity and the specified load factor. * * @param initialCapacity the initial capacity of the hashtable. * @param loadFactor the load factor of the hashtable. * @exception IllegalArgumentException if the initial capacity is less * than zero, or if the load factor is nonpositive. */ public Hashtable(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal Load: \"+loadFactor); if (initialCapacity==0) initialCapacity = 1; this.loadFactor = loadFactor; table = new Entry&lt;?,?&gt;[initialCapacity]; threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1); } /** * Constructs a new, empty hashtable with the specified initial capacity * and default load factor (0.75). * * @param initialCapacity the initial capacity of the hashtable. * @exception IllegalArgumentException if the initial capacity is less * than zero. */ public Hashtable(int initialCapacity) { this(initialCapacity, 0.75f); } /** * Constructs a new, empty hashtable with a default initial capacity (11) * and load factor (0.75). */ public Hashtable() { this(11, 0.75f); } /** * Constructs a new hashtable with the same mappings as the given * Map. The hashtable is created with an initial capacity sufficient to * hold the mappings in the given Map and a default load factor (0.75). * * @param t the map whose mappings are to be placed in this map. * @throws NullPointerException if the specified map is null. * @since 1.2 */ public Hashtable(Map&lt;? extends K, ? extends V&gt; t) { this(Math.max(2*t.size(), 11), 0.75f); putAll(t); } 5.选取适合的Hash数据结构 只有HashTable是同步的，提供线程安全 HashMap和HashTable是无序的， LinkedHashMap维护插入和访问插入顺序 TreeMap维持升序排序，也可自己定义Comparator接口，实现自定义排序 HashMap和HashTable以及LinkedHashMap允许null作为键和值，但只允许一个单键 TreeMap不允许null作为键，允许空值","categories":[{"name":"软件技术","slug":"软件技术","permalink":"http://www.liniuniu.top/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"},{"name":"java","slug":"软件技术/java","permalink":"http://www.liniuniu.top/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/"}],"tags":[{"name":"Map","slug":"Map","permalink":"http://www.liniuniu.top/tags/Map/"}],"author":"Mark"},{"title":"437. Path Sum III 路径总和 III","slug":"Leetcode437","date":"2021-09-27T06:13:00.000Z","updated":"2021-09-28T12:45:10.063Z","comments":true,"path":"posts/7e0676ea.html","link":"","permalink":"http://www.liniuniu.top/posts/7e0676ea.html","excerpt":"","text":"Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum. The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes). Example 1: Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8 Output: 3 Explanation: The paths that sum to 8 are shown. Example 2: Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: 3 Constraints: The number of nodes in the tree is in the range [0, 1000]. -109 &lt;= Node.val &lt;= 109 -1000 &lt;= targetSum &lt;= 1000 分析针对二叉树相关的问题，优先考虑递归，可以设置两个函数，主函数和统计路径数量的遍历函数 主函数：遍历所有节点，传递节点给遍历函数 遍历函数：得到节点后，以节点为根节点，累加路径的数量 方法使用递归，遍历二叉树节点，并递归以此节点为根的二叉树，统计路径和 代码/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int pathSum(TreeNode root, int targetSum) { if(root==null) return 0; return traverse(root,targetSum)+pathSum(root.left,targetSum)+pathSum(root.right,targetSum); } public int traverse(TreeNode node,int sum) { if(node==null) return 0; return (sum==node.val?1:0)+traverse(node.left,sum-node.val)+traverse(node.right,sum-node.val); } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"},{"name":"recursion","slug":"recursion","permalink":"http://www.liniuniu.top/tags/recursion/"}],"author":"Mark"},{"title":"Leetcode 205. Isomorphic Strings 同构字符串","slug":"Leetcode205","date":"2021-09-26T15:01:00.000Z","updated":"2021-09-28T12:59:09.843Z","comments":true,"path":"posts/3d60dd91.html","link":"","permalink":"http://www.liniuniu.top/posts/3d60dd91.html","excerpt":"","text":"Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself. Example 1: Input: s = \"egg\", t = \"add\" Output: true Example 2: Input: s = \"foo\", t = \"bar\" Output: false Example 3: Input: s = \"paper\", t = \"title\" Output: true 分析：这道题要求判断两个字符串是否具有相同的结构，在遍历过程中，如果遍历到两个字符串中的字符，上一次出现的位置不同，那么可以判定它们是不同结构的 方法初始化两个空间为256的数组，遍历到两个字符串中的字符，上一次出现的位置不同，那么可以判定它们是不同结构的 代码class Solution { public boolean isIsomorphic(String s, String t) { int[] m1=new int[256]; int[] m2=new int[256]; for(int i=0;i&lt;s.length();i++) { if(m1[s.charAt(i)]!=m2[t.charAt(i)]) return false; else { m1[s.charAt(i)]=i+1; m2[t.charAt(i)]=i+1; } } return true; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"},{"title":"Leetcode 680. Valid Palindrome II 验证回文子串II","slug":"Leetcode680","date":"2021-09-26T04:30:00.000Z","updated":"2021-09-26T04:34:19.869Z","comments":true,"path":"posts/190801a7.html","link":"","permalink":"http://www.liniuniu.top/posts/190801a7.html","excerpt":"","text":"Given a string s, return true if the s can be palindrome after deleting at most one character from it. Example 1: Input: s = \"aba\" Output: true Example 2: Input: s = \"abca\" Output: true Explanation: You could delete the character 'c'. Example 3: Input: s = \"abc\" Output: false Constraints: 1 &lt;= s.length &lt;= 105 s consists of lowercase English letters. 分析： 这道题求一个字符串在允许删掉一个字符的情况下，是否能成为回文串，由于回文子串的特性是首位相同，因此采用双指针方法解决问题。当双指针前后遍历字符串，遇到前后所指字符不同的情况时，有两种可能性，删除前指针或后指针所指的字符，那么可以采用||运算符。 方法双指针遍历字符，若遇到不同的字符，则转到删除前或后指针所指字符后的判断函数。 代码class Solution { public boolean validPalindrome(String s) { int l=0;int r=s.length()-1; while(l&lt;r) { if(s.charAt(l)==s.charAt(r)) { l++; r--; } else { return func(s,l+1,r)||func(s,l,r-1); } } return true; } public boolean func(String s,int l,int r) { while(l&lt;r) { if(s.charAt(l)==s.charAt(r)) { l++; r--; } else { return false; } } return true; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"},{"name":"pointer","slug":"pointer","permalink":"http://www.liniuniu.top/tags/pointer/"}],"author":"Mark"},{"title":"Leetcode 44. Wildcard Matching 通配符匹配","slug":"Leetcode44","date":"2021-09-26T04:02:00.000Z","updated":"2021-09-26T04:34:19.862Z","comments":true,"path":"posts/34851722.html","link":"","permalink":"http://www.liniuniu.top/posts/34851722.html","excerpt":"","text":"Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where: '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). Example 1: Input: s = \"aa\", p = \"a\" Output: false Explanation: \"a\" does not match the entire string \"aa\". Example 2: Input: s = \"aa\", p = \"*\" Output: true Explanation: '*' matches any sequence. Example 3: Input: s = \"cb\", p = \"?a\" Output: false Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'. Example 4: Input: s = \"adceb\", p = \"*a*b\" Output: true Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring \"dce\". Example 5: Input: s = \"acdcb\", p = \"a*c?b\" Output: false Constraints: 0 &lt;= s.length, p.length &lt;= 2000 s contains only lowercase English letters. p contains only lowercase English letters, '?' or '*'. 分析：这道题求两个字符串是否匹配，考虑用动态规划解决问题，通配符在匹配时有三种情况， 第一种，s.charAt(i)==p.charAt(j)，那么其能否匹配与dp[i-1][j-1]相同 第二种，p.charAt(j)==’?’，这时无论s.charAt(i)的字符为何，皆可以匹配，与dp[i-1][j-1]相同 第三种，p.charAt(j)==’*’，这时相关情况可分为两类 ​ 第一类，*用于表示空格，此时与dp[i][j-1]相同 ​ 第二类，*用于表示一串字符，此时与dp[i-1][j]相同 方法根据以上分析，采用动态规划方法，动态规划方程为： dp[i][j]=dp[i-1][j-1](s.charAt(i)==p.charAt(j)||p.charAt(j)==’?’) dp[i][j]=dp[i-1][j]||dp[i][j-1])(p.charAt(j)==’*’)，代码如下： 代码class Solution { public boolean isMatch(String s, String p) { int m=s.length();int n=p.length(); boolean[][] dp=new boolean[m+1][n+1]; for(int i=1;i&lt;=m;i++) { dp[i-1][0]=false; } boolean flag=true; for(int i=1;i&lt;=n;i++) { if(p.charAt(i-1)!='*') { flag=false; } dp[0][i]=flag; } dp[0][0]=true; for(int i=1;i&lt;=m;i++) { for(int j=1;j&lt;=n;j++) { if(s.charAt(i-1)==p.charAt(j-1)||p.charAt(j-1)=='?') { dp[i][j]=dp[i-1][j-1]; } else if(p.charAt(j-1)=='*'){ dp[i][j]=dp[i-1][j]||dp[i][j-1]; } } } return dp[m][n]; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"},{"name":"dp","slug":"dp","permalink":"http://www.liniuniu.top/tags/dp/"}],"author":"Mark"},{"title":"Leetcode 115. Distinct Subsequences 两个字符串的删除操作","slug":"Leetcode115","date":"2021-09-25T06:02:00.000Z","updated":"2021-09-25T15:31:35.887Z","comments":true,"path":"posts/973b595.html","link":"","permalink":"http://www.liniuniu.top/posts/973b595.html","excerpt":"","text":"Given two strings s and t, return the number of distinct subsequences of s which equals t. A string’s subsequence is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters’ relative positions. (i.e., “ACE” is a subsequence of “ABCDE” while “AEC” is not). It is guaranteed the answer fits on a 32-bit signed integer. Example 1: Input: s = \"rabbbit\", t = \"rabbit\" Output: 3 Explanation: As shown below, there are 3 ways you can generate \"rabbit\" from S. rabbbit rabbbit rabbbit Example 2: Input: s = \"babgbag\", t = \"bag\" Output: 5 Explanation: As shown below, there are 5 ways you can generate \"bag\" from S. babgbag babgbag babgbag babgbag babgbag Constraints: 1 &lt;= s.length, t.length &lt;= 1000s and t consist of English letters. 分析： 这道题求字符串t在字符串s中出现的个数，看到字符串的个数求解，考虑用动态规划去解决问题。一级遍历字符串s，二级遍历t时，当s.charAt(i)==t.charAt(j)时，这时会出现两种情况，一种是，t中新出现的t.charAt(i)对于结果无影响，那么让其等于上一层即可,即dp[i][j]=dp[i-1][j-1]，第二种是，t中新出现的t.charAt(i)对于结在s的0—（i-1）之中存在,dp[i][j]=dp[i-1][j]。 如果s.charAt(i)!=t.charAt(j)那么上文中的第一种条件将不可能存在，那么只有第二种，即 dp[i][j]=dp[i-1][j] 方法根据以上分析，采用动态规划方法，动态规划方程为：dp[i][j]=dp[i-1][j-1]+dp[i-1][j](s.charAt(i)==t.charAt[j]),dp[i][j]=dp[i-1][j](s.charAt(i)!=t.charAt(j))，代码如下： 代码class Solution { public int numDistinct(String s, String t) { int m=s.length();int n=t.length(); int[][] dp=new int[m+1][n+1]; if(m&lt;n) { return 0; } for(int i=0;i&lt;=m;i++) { dp[i][0]=1; } for(int i=1;i&lt;=m;i++) { for(int j=1;j&lt;=n;j++) { if(s.charAt(i-1)==t.charAt(j-1)) { dp[i][j]=dp[i-1][j-1]+dp[i-1][j]; } else { dp[i][j]=dp[i-1][j]; } } } return dp[m][n]; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"},{"name":"dp","slug":"dp","permalink":"http://www.liniuniu.top/tags/dp/"}],"author":"Mark"},{"title":"Leetcode 371. Sum of Two Integers 两整数之和","slug":"Leetcode371","date":"2021-09-25T06:02:00.000Z","updated":"2021-09-26T04:34:19.853Z","comments":true,"path":"posts/22becddc.html","link":"","permalink":"http://www.liniuniu.top/posts/22becddc.html","excerpt":"","text":"Given two integers a and b, return the sum of the two integers without using the operators + and -. Example 1: Input: a = 1, b = 2 Output: 3 Example 2: Input: a = 2, b = 3 Output: 5 Constraints: -1000 &lt;= a, b &lt;= 1000 分析： 题目的要求非常简单，在不使用+-号及其相关符号的原则下，实现两个整数相加，优先考虑位运算，可以把需要进位和不需要进位的部分迭代运算。 方法根据以上分析，对于需要进位的部分，用(a&amp;b)&lt;&lt;1实现，对于不需要进位，则用a^b的实现，不断迭代，代码如下： 代码class Solution { public int getSum(int a, int b) { while(a!=0) { int index=(a&amp;b)&lt;&lt;1; b=a^b; a=index; } return b; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"},{"name":"bit","slug":"bit","permalink":"http://www.liniuniu.top/tags/bit/"}],"author":"Mark"},{"title":"Leetcode 430. Flatten a Multilevel Doubly Linked List 扁平化多级双向链表","slug":"Leetcode430","date":"2021-09-25T06:02:00.000Z","updated":"2021-09-25T15:31:35.890Z","comments":true,"path":"posts/345fb18b.html","link":"","permalink":"http://www.liniuniu.top/posts/345fb18b.html","excerpt":"","text":"Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same. In one step, you can delete exactly one character in either string. Example 1: Input: word1 = \"sea\", word2 = \"eat\" Output: 2 Explanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\". Example 2: Input: word1 = \"leetcode\", word2 = \"etco\" Output: 4 Constraints: 1 &lt;= word1.length, word2.length &lt;= 500word1 and word2 consist of only lowercase English letters. 分析：这道题求找到使得word1和word2相同所需的最小步数，每步可以删除一个字符。字符串相关的问题，首先考虑动态规划，当遍历word1和word2时，有两种可能性情况，第一种：word1.charAt(i)==word2.charAt(j)，第二种：word1.charAt(i)!=word2.charAt(j) 方法采用动态规划方法，动态规划方程为：dp[i][j]=dp[i-1][j-1](word(i)==word[j]),dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+1(word[i]!=word[j])，代码如下： 代码class Solution { public int minDistance(String word1, String word2) { int[][] dp=new int[word1.length()+1][word2.length()+1]; for(int i=0;i&lt;word1.length()+1;i++) { dp[i][0]=i; } for(int i=0;i&lt;word2.length()+1;i++) { dp[0][i]=i; } for(int i=1;i&lt;word1.length()+1;i++) { for(int j=1;j&lt;word2.length()+1;j++) { if(word1.charAt(i-1)==word2.charAt(j-1)) { dp[i][j]=dp[i-1][j-1]; } if(word1.charAt(i-1)!=word2.charAt(j-1)) { dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+1; } } } return dp[word1.length()][word2.length()]; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"},{"name":"dp","slug":"dp","permalink":"http://www.liniuniu.top/tags/dp/"}],"author":"Mark"},{"title":"Git的使用心得","slug":"Git_course","date":"2021-09-24T03:30:00.000Z","updated":"2021-09-24T09:53:41.726Z","comments":true,"path":"posts/547feeee.html","link":"","permalink":"http://www.liniuniu.top/posts/547feeee.html","excerpt":"","text":"1.Git在Windows上的安装官方版本可以在 Git 官方网站下载。 打开 https://git-scm.com/download/win，下载安装即可。 2.Git的配置安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改： $ git config --global user.name \"li-niuniu\" $ git config --global user.email myloveislizihao@163.com 检查配置信息如果想要检查你的配置，可以使用 git config --list 命令来列出所有 Git 当时能找到的配置。 3.Git文件的各种状态Git工作流程一般工作流程如下： 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 推送到远程库 Git的工作区、暂存区和版本库 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。 文件的已追踪和未追踪工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是 Git 已经知道的文件。 工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们。 编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 在工作时，你可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。 克隆远程仓库克隆仓库的命令是 git clone &lt;url&gt; 。 比如，要克隆提交作业的仓库，可以用下面的命令： $ git clone https://gitee.com/fengjie_zstu/graduate-single-program2021.git 检查当前文件状态可以用 git status 命令查看哪些文件处于什么状态。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出： 所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 现在，创建一个新的test/test.txt文件。 如果之前并不存在这个文件，使用 git status 命令，你将看到一个新的未跟踪文件： 使用命令 git add可以跟踪一个文件。 所以，要跟踪 test/test.txt 文件，运行： git add test 此时再运行 git status 命令，会看到 test/test.txt 文件已被跟踪，并处于暂存状态: 如果修改一个已被跟踪的文件，运行git add命令可以重新放到暂存区 提交更新已修改但未暂存的文件只会保留在本地磁盘。 所以，每次准备提交前，先用 git status 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 git commit： git commit 查看提交历史在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 git log 命令。 去掉已经托管在本地的文件如果想去掉已经托管在本地的文件，将文件变为未追踪的文件，可以使用git rm命令： 4.远程仓库查看远程仓库如果想查看你已经配置的远程仓库服务器，可以运行 git remote -v 命令。 它会列出你指定的每一个远程服务器的简写和对应的URL。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字： 添加远程仓库运行 git remote add &lt;shortname&gt; &lt;url&gt; 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写： 现在可以在命令行中使用字符串 abc 来代替整个 URL。 例如，如果你想拉取URL对应的仓库中有但你没有的信息，可以运行 git pull origin： 这说明目前远程仓库的内容已经全部被抓取到本地仓库 推送到远程仓库当你想分享你的项目时，必须将其推送到上游。 这个命令：git push &lt;remote&gt; &lt;branch&gt;。 当你想要将 master 分支推送到 origin 服务器时（克隆时通常会自动帮你设置好那两个名字）， 那么运行这个命令就可以将你所做的备份到服务器： $ git push origin master 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。 远程仓库的重命名与移除以运行 git remote rename 来修改一个远程仓库的简写名。 例如，想要将 abc 重命名为 def，可以用 git remote rename 这样做： 值得注意的是这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 abc/master 的现在会引用 def/master。 如果想要移除一个远程仓库,可以使用 git remote remove 或 git remote rm ： 5.Git分支分支创建Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令： $ git branch testing 这会在当前所在的提交对象上创建一个指针。 当需要在非当前分支上工作时，需要使用git checkout命令: $ git checkout testing 某些场景下，需要合并两个分支，则需要使用git merge命令: $ git checkout master $ git merge testing 这样testing分支中的内容会合并至master之中 6.在Intellij Idea中暂存，提交并推送暂存当做了更改之后， 右键文件，点击git分支下的add，将其放到暂存区中 提交点击git分支下的commit file，并在弹出的对话框中输入提交信息，将其提交本地库中 推送点击右下角branch分支，核对本地分支及远程库之后，点击local branches下的branch，点击push即可 7.在Vscode中暂存，提交并推送暂存当做了更改之后， 点击左边第三个，源代码管理 点击更改栏目下的test_vscode.md右边的加号，将其放到暂存的更改中 提交点击源代码管理右侧的对号，并在弹出的对话框填入提交消息 推送核对本地分支及远程库之后，在如下界面点击推送即可 参考链接： https://git-scm.com/doc","categories":[{"name":"软件技术","slug":"软件技术","permalink":"http://www.liniuniu.top/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.liniuniu.top/tags/Git/"},{"name":"代码托管","slug":"代码托管","permalink":"http://www.liniuniu.top/tags/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1/"}],"author":"Mark"},{"title":"Leetcode 430. Flatten a Multilevel Doubly Linked List 扁平化多级双向链表","slug":"Leetcode583","date":"2021-09-24T03:02:00.000Z","updated":"2021-09-25T15:31:35.893Z","comments":true,"path":"posts/345fb18b.html","link":"","permalink":"http://www.liniuniu.top/posts/345fb18b.html","excerpt":"","text":"You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below. Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list. Example 1: Input: head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12] Output: [1,2,3,7,8,11,12,9,10,4,5,6] Explanation The multilevel linked list in the input is as follows: After flattening the multilevel linked list it becomes: Example 2: Input: head = [1,2,null,3] Output: [1,3,2] Explanation: The input multilevel linked list is as follows: 1---2---NULL | 3---NULL Example 3: Input: head = [] Output: [] How multilevel linked list is represented in test case: We use the multilevel linked list from Example 1 above: 1---2---3---4---5---6--NULL | 7---8---9---10--NULL | 11--12--NULL The serialization of each level is as follows: [1,2,3,4,5,6,null] [7,8,9,10,null] [11,12,null] To serialize all levels together we will add nulls in each level to signify no node connects to the upper node of the previous level. The serialization becomes: [1,2,3,4,5,6,null] [null,null,7,8,9,10,null] [null,11,12,null] Merging the serialization of each level and removing trailing nulls we obtain: [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12] Constraints: The number of Nodes will not exceed 1000. 1 &lt;= Node.val &lt;= 10^5 分析：这道题给出一个多级双向链表，要求将其扁平化，也就是将多级转变为单极，这种形式与二叉树链表的先序遍历非常相似，因此优先考虑深度优先搜索遍历 方法从head开始遍历链表，当遇到存在child节点时，则保存node.next，然后dfs node.child（与二叉树先序优先搜索遍历相似），将node.next与node.child构建先后续关系，node.child置于null。dfs最终得到child节点的尾节点，将尾节点和之前保存的node.next构建先后续关系，dfs深层遍历后回溯到之前的层，把每一层child节点的前后构建完成。 代码* // Definition for a Node. class Node { public int val; public Node prev; public Node next; public Node child; }; */ class Solution { public Node flatten(Node head) { dfs(head); return head; } public Node dfs(Node node) { Node cur=node; Node last=null; while(cur!=null) { Node next=cur.next; if(cur.child!=null) { Node childLast=dfs(cur.child); next=cur.next; cur.next=cur.child; cur.child.prev=cur; if(next!=null) { childLast.next=next; next.prev=childLast; } cur.child=null; last=childLast; } else { last=cur; } cur=next; } return last; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"},{"name":"dfs","slug":"dfs","permalink":"http://www.liniuniu.top/tags/dfs/"}],"author":"Mark"},{"title":"Leetcode 58. Length of Last Word 最后一个单词的长度","slug":"Leetcode58","date":"2021-09-23T12:31:00.000Z","updated":"2021-09-23T12:37:31.725Z","comments":true,"path":"posts/776c8164.html","link":"","permalink":"http://www.liniuniu.top/posts/776c8164.html","excerpt":"","text":"Given a string s consisting of some words separated by some number of spaces, return the length of the last word in the string. A word is a maximal substring consisting of non-space characters only. Example 1: Input: s = \"Hello World\" Output: 5 Explanation: The last word is \"World\" with length 5. Example 2: Input: s = \" fly me to the moon \" Output: 4 Explanation: The last word is \"moon\" with length 4. Example 3: Input: s = \"luffy is still joyboy\" Output: 6 Explanation: The last word is \"joyboy\" with length 6. Constraints: 1 &lt;= s.length &lt;= 104 s consists of only English letters and spaces ' '. There will be at least one word in s. 分析：这道题求一个句子之中最后一个单词的长度，最简单的方法就是判断是不是为空格，是空格就把sum置0，否则累加，最终得到的就是最后一个单词的长度 方法遇到空格就把sum置0，否则累加，最终得到最后一个单词的长度 代码class Solution { public int lengthOfLastWord(String s) { int sum=0;int ans=0; for(char ch:s.toCharArray()) { if(ch!=' ') { sum++; ans=sum; } else { sum=0; } } return ans; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"},{"title":"Leetcode 673. Number of Longest Increasing Subsequence 最长递增子序列的个数","slug":"Leetcode673","date":"2021-09-23T12:04:00.000Z","updated":"2021-09-24T03:25:57.057Z","comments":true,"path":"posts/e88ed89b.html","link":"","permalink":"http://www.liniuniu.top/posts/e88ed89b.html","excerpt":"","text":"Given an integer array nums, return the number of longest increasing subsequences. Notice that the sequence has to be strictly increasing. Example 1: Input: nums = [1,3,5,4,7] Output: 2 Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7]. Example 2: Input: nums = [2,2,2,2,2] Output: 5 Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5. Constraints: 1 &lt;= nums.length &lt;= 2000 -10^6 &lt;= nums[i] &lt;= 10^6 分析：这道题给出一个数组，要求求出最长的递增的子序列的总数，这里有两个限定词，最长和递增。题目为求总数，可以用动态规划方法，限定词为最长，可以设置为一个dp数组，递增放到循环里进行判断，故设置len[i]表示结尾为nums[i]的最长子序列的长度，cnt[i]表示结尾为nums[i]的最长子序列的数量。 方法对于数组中或中的每个元素，它们都带有三个字段：1）最大增加/减少长度以当前元素结束，2）它自己的值，3）最大长度的总数，并且每次我们访问一个元素时，我们都会使用它来更新1和 3设置len[i]表示结尾为nums[i]的最长子序列的长度，cnt[i]表示结尾为nums[i]的最长子序列的数量。 代码class Solution { public int findNumberOfLIS(int[] nums) { int n=nums.length; int ans=0;int max=0; int[] len=new int[n];//长度 int[] cnt=new int[n];//个数 for(int i=0;i&lt;n;i++) { len[i]=cnt[i]=1; for(int j=0;j&lt;i;j++) { if(nums[i]&gt;nums[j]) { if(len[i]==len[j]+1) { cnt[i]+=cnt[j]; } else if(len[i]&lt;len[j]+1) { len[i]=len[j]+1; cnt[i]=cnt[j]; } } } //求最大递增子序列的数量 if(max==len[i]) { ans+=cnt[i]; } if(max&lt;len[i]) { ans=cnt[i]; max=len[i]; } } return ans; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"},{"title":"Leetcode 650. 2 Keys Keyboard 只有两个键的键盘","slug":"Leetcode650","date":"2021-09-23T10:54:00.000Z","updated":"2021-09-23T12:37:31.719Z","comments":true,"path":"posts/c4b7fa82.html","link":"","permalink":"http://www.liniuniu.top/posts/c4b7fa82.html","excerpt":"","text":"There is only one character 'A' on the screen of a notepad. You can perform two operations on this notepad for each step: Copy All: You can copy all the characters present on the screen (a partial copy is not allowed). Paste: You can paste the characters which are copied last time. Given an integer n, return the minimum number of operations to get the character 'A' exactly n times on the screen. Example 1: Input: n = 3 Output: 3 Explanation: Intitally, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'. Example 2: Input: n = 1 Output: 0 Constraints: 1 &lt;= n &lt;= 1000 分析：这道题主要说，如果要从A获得AA，需要2个额外的步骤（全部复制然后粘贴），如果要从A获得AAA，我们需要三个额外的步骤，（全部复制，然后粘贴，再次粘贴）。为了生成 AAAA，我们需要 AA 的 2 个步骤。但是，要获得 AAAAAAAA，最好的方法是从 AAAA 获得，有 2 个步骤（全部复制然后粘贴）本质上，我们找到了下一个更短的序列，它可以被复制然后多次粘贴以生成所需的序列。当我们找到一个可以完美分割我们所需序列长度的长度时，我们就不需要检查任何更短的序列。 方法看到字符串相关，最容易想到的便是动态规划，动态规划方程经验证可写为，dp[i]=dp[j]+i/j，其中dp[i]是目前得到记事本相应字符个数所需的最少操作次数，dp[j]为之前（最终匹配到的为i的约数）。如i=9，j=3，那么经此动态规划方程运算，则dp[i]会在dp[j]的基础上加3，相当于复制，粘贴，粘贴。 代码class Solution { public int minSteps(int n) { int[] dp=new int[n+1]; for(int i=2;i&lt;=n;i++) { dp[i]=i; for(int j=i-1;j&gt;1;j--) { if(i%j==0) { dp[i]=dp[j]+i/j; break; } } } return dp[n]; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"},{"title":"Leetcode 326. Power of Three 3的幂","slug":"Leetcode326","date":"2021-09-22T06:37:00.000Z","updated":"2021-09-23T11:13:00.532Z","comments":true,"path":"posts/3e4049d7.html","link":"","permalink":"http://www.liniuniu.top/posts/3e4049d7.html","excerpt":"","text":"Given an integer n, return true if it is a power of three. Otherwise, return false. An integer n is a power of three, if there exists an integer x such that n == 3x. Example 1: Input: n = 27 Output: true Example 2: Input: n = 0 Output: false Example 3: Input: n = 9 Output: true Example 4: Input: n = 45 Output: false Constraints: -2^31 &lt;= n &lt;= 2^31 - 1 分析：这道题要判断n是否是3的幂方法一最容易想到的思路是，用n不断除3，如果能除到1且无余数则为3的幂，否则不是。整个过程的时间复杂度为log(n)，时间复杂度为log(1) 代码class Solution { public boolean isPowerOfThree(int n) { while(n!=0&amp;&amp;n%3==0) { n/=3; } return n==1; } } 方法二在int可表示的范围内，3的最大幂为3的19次幂，这个数字仅是3的幂数的公倍数，所以可以从n是否3的19次幂的约数来判断。这个过程仅做了常数级运算，时间复杂度为log(1)，空间复杂度为log(1) 代码class Solution { public boolean isPowerOfThree(int n) { int max=(int)Math.pow(3,19); if(n&gt;0&amp;&amp;max%n==0) { return true; } return false; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"},{"title":"Leetcode 725. Split Linked List in Parts 分隔链表","slug":"Leetcode725","date":"2021-09-22T06:34:00.000Z","updated":"2021-09-23T11:13:30.518Z","comments":true,"path":"posts/b75f9389.html","link":"","permalink":"http://www.liniuniu.top/posts/b75f9389.html","excerpt":"","text":"Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts. The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null. The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later. Return an array of the k parts. Example 1: Input: head = [1,2,3], k = 5 Output: [[1],[2],[3],[],[]] Explanation: The first element output[0] has output[0].val = 1, output[0].next = null. The last element output[4] is null, but its string representation as a ListNode is []. Example 2: Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3 Output: [[1,2,3,4],[5,6,7],[8,9,10]] Explanation: The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts. Constraints: The number of nodes in the list is in the range [0, 1000]. 0 &lt;= Node.val &lt;= 1000 1 &lt;= k &lt;= 50 这道题要把一个ListNode链表，平均分隔为k段，有部分数量可能多一个，放到前面。对于一道 Medium 题而言，思路比较清晰，主要就是考察了一个对链表的使用和对细节的把握，可以使用两个for循环，把被分割的每一段链表的开端设为上一段的next， res[i]=cur; int part=every+(suff&gt;i?1:0); 对于每一段链表的结尾，则采用如下方式，让末尾的后置设为null ListNode next=cur.next; cur.next=null; cur=next; 然后比较这个距离和，跟总距离减去该距离所得结果之间的较小值返回即可，参见代码如下： 解法： class Solution { public ListNode[] splitListToParts(ListNode head, int k) { int sum=0; ListNode cur=head; while(head!=null) { sum++; head=head.next; } int suff=sum%k;int every=sum/k; ListNode[] res=new ListNode[k]; for(int i=0;i&lt;k&amp;&amp;cur!=null;i++) { res[i]=cur; int part=every+(suff&gt;i?1:0); for(int j=1;j&lt;part;j++) { cur=cur.next; } ListNode next=cur.next; cur.next=null; cur=next; } return res; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"}],"categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"java","slug":"算法/java","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/java/"},{"name":"软件技术","slug":"软件技术","permalink":"http://www.liniuniu.top/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"},{"name":"java","slug":"软件技术/java","permalink":"http://www.liniuniu.top/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/java/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"},{"name":"dfs","slug":"dfs","permalink":"http://www.liniuniu.top/tags/dfs/"},{"name":"backtrace","slug":"backtrace","permalink":"http://www.liniuniu.top/tags/backtrace/"},{"name":"binarySearch","slug":"binarySearch","permalink":"http://www.liniuniu.top/tags/binarySearch/"},{"name":"dp","slug":"dp","permalink":"http://www.liniuniu.top/tags/dp/"},{"name":"Map","slug":"Map","permalink":"http://www.liniuniu.top/tags/Map/"},{"name":"recursion","slug":"recursion","permalink":"http://www.liniuniu.top/tags/recursion/"},{"name":"pointer","slug":"pointer","permalink":"http://www.liniuniu.top/tags/pointer/"},{"name":"bit","slug":"bit","permalink":"http://www.liniuniu.top/tags/bit/"},{"name":"Git","slug":"Git","permalink":"http://www.liniuniu.top/tags/Git/"},{"name":"代码托管","slug":"代码托管","permalink":"http://www.liniuniu.top/tags/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1/"}]}