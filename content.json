{"meta":{"title":"Mark","subtitle":"Markの博客","description":"硕士研究生 | 计算机技术 | 软件开发","author":"Mark","url":"http://www.liniuniu.top","root":"/"},"pages":[{"title":"","date":"2021-09-22T08:04:15.502Z","updated":"2021-09-22T08:04:15.502Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"http://www.liniuniu.top/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-22T08:04:15.441Z","comments":true,"path":"List/index.html","permalink":"http://www.liniuniu.top/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-22T08:04:15.434Z","comments":true,"path":"404.html","permalink":"http://www.liniuniu.top/404.html","excerpt":"","text":""},{"title":"","date":"2021-09-22T08:04:15.503Z","updated":"2021-09-22T08:04:15.503Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"http://www.liniuniu.top/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-22T08:04:15.501Z","comments":true,"path":"archives/index.html","permalink":"http://www.liniuniu.top/archives/index.html","excerpt":"","text":""},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-22T08:04:15.501Z","comments":true,"path":"about/index.html","permalink":"http://www.liniuniu.top/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-22T08:04:15.502Z","comments":true,"path":"categories/index.html","permalink":"http://www.liniuniu.top/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-09-22T09:01:00.000Z","updated":"2021-09-22T09:01:56.551Z","comments":true,"path":"contact/index.html","permalink":"http://www.liniuniu.top/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Markの友链信息 博客名称: Markの博客 博客网址: http://www.liniuniu.top 博客头像: https://z3.ax1x.com/2021/09/22/4UQnjP.jpg 博客介绍: Experience is the father of wisdom and memory the mother"},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-09-22T08:04:15.502Z","comments":true,"path":"census/index.html","permalink":"http://www.liniuniu.top/census/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-22T08:04:15.503Z","comments":true,"path":"resource/index.html","permalink":"http://www.liniuniu.top/resource/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-09-22T08:04:15.503Z","comments":true,"path":"friends/index.html","permalink":"http://www.liniuniu.top/friends/index.html","excerpt":"","text":""},{"title":"资源","date":"2020-02-10T14:07:08.000Z","updated":"2021-09-22T02:41:18.956Z","comments":false,"path":"resources/index.html","permalink":"http://www.liniuniu.top/resources/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-22T08:04:15.503Z","comments":true,"path":"tags/index.html","permalink":"http://www.liniuniu.top/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-09-22T12:33:48.515Z","updated":"2021-09-22T08:04:15.438Z","comments":true,"path":"List/galleries/index.html","permalink":"http://www.liniuniu.top/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-22T08:04:15.441Z","comments":true,"path":"List/movies/index.html","permalink":"http://www.liniuniu.top/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-22T08:04:15.442Z","comments":true,"path":"List/tools/index.html","permalink":"http://www.liniuniu.top/List/tools/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-09-22T08:04:15.439Z","updated":"2021-09-22T08:04:15.439Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-22T08:04:15.441Z","comments":true,"path":"List/music/index.html","permalink":"http://www.liniuniu.top/List/music/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-09-22T12:33:35.648Z","updated":"2021-09-22T08:04:15.439Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-09-22T12:33:00.851Z","updated":"2021-09-22T08:04:15.438Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-09-22T08:04:15.439Z","updated":"2021-09-22T08:04:15.439Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-09-22T08:04:15.440Z","updated":"2021-09-22T08:04:15.440Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-09-22T08:04:15.439Z","updated":"2021-09-22T08:04:15.439Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-09-22T08:04:15.440Z","updated":"2021-09-22T08:04:15.440Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-09-22T08:04:15.440Z","updated":"2021-09-22T08:04:15.440Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-09-22T08:04:15.440Z","updated":"2021-09-22T08:04:15.440Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-09-22T08:04:15.440Z","updated":"2021-09-22T08:04:15.440Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-09-22T08:04:15.441Z","updated":"2021-09-22T08:04:15.441Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-09-22T08:04:15.441Z","updated":"2021-09-22T08:04:15.441Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"Git的使用心得","slug":"Git_course","date":"2021-09-24T03:30:00.000Z","updated":"2021-09-24T09:53:41.726Z","comments":true,"path":"posts/547feeee.html","link":"","permalink":"http://www.liniuniu.top/posts/547feeee.html","excerpt":"","text":"1.Git在Windows上的安装官方版本可以在 Git 官方网站下载。 打开 https://git-scm.com/download/win，下载安装即可。 2.Git的配置安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改： $ git config --global user.name \"li-niuniu\" $ git config --global user.email myloveislizihao@163.com 检查配置信息如果想要检查你的配置，可以使用 git config --list 命令来列出所有 Git 当时能找到的配置。 3.Git文件的各种状态Git工作流程一般工作流程如下： 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 推送到远程库 Git的工作区、暂存区和版本库 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。 文件的已追踪和未追踪工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是 Git 已经知道的文件。 工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们。 编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 在工作时，你可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。 克隆远程仓库克隆仓库的命令是 git clone &lt;url&gt; 。 比如，要克隆提交作业的仓库，可以用下面的命令： $ git clone https://gitee.com/fengjie_zstu/graduate-single-program2021.git 检查当前文件状态可以用 git status 命令查看哪些文件处于什么状态。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出： 所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 现在，创建一个新的test/test.txt文件。 如果之前并不存在这个文件，使用 git status 命令，你将看到一个新的未跟踪文件： 使用命令 git add可以跟踪一个文件。 所以，要跟踪 test/test.txt 文件，运行： git add test 此时再运行 git status 命令，会看到 test/test.txt 文件已被跟踪，并处于暂存状态: 如果修改一个已被跟踪的文件，运行git add命令可以重新放到暂存区 提交更新已修改但未暂存的文件只会保留在本地磁盘。 所以，每次准备提交前，先用 git status 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 git commit： git commit 查看提交历史在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 git log 命令。 去掉已经托管在本地的文件如果想去掉已经托管在本地的文件，将文件变为未追踪的文件，可以使用git rm命令： 4.远程仓库查看远程仓库如果想查看你已经配置的远程仓库服务器，可以运行 git remote -v 命令。 它会列出你指定的每一个远程服务器的简写和对应的URL。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字： 添加远程仓库运行 git remote add &lt;shortname&gt; &lt;url&gt; 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写： 现在可以在命令行中使用字符串 abc 来代替整个 URL。 例如，如果你想拉取URL对应的仓库中有但你没有的信息，可以运行 git pull origin： 这说明目前远程仓库的内容已经全部被抓取到本地仓库 推送到远程仓库当你想分享你的项目时，必须将其推送到上游。 这个命令：git push &lt;remote&gt; &lt;branch&gt;。 当你想要将 master 分支推送到 origin 服务器时（克隆时通常会自动帮你设置好那两个名字）， 那么运行这个命令就可以将你所做的备份到服务器： $ git push origin master 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。 远程仓库的重命名与移除以运行 git remote rename 来修改一个远程仓库的简写名。 例如，想要将 abc 重命名为 def，可以用 git remote rename 这样做： 值得注意的是这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 abc/master 的现在会引用 def/master。 如果想要移除一个远程仓库,可以使用 git remote remove 或 git remote rm ： 5.Git分支分支创建Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令： $ git branch testing 这会在当前所在的提交对象上创建一个指针。 当需要在非当前分支上工作时，需要使用git checkout命令: $ git checkout testing 某些场景下，需要合并两个分支，则需要使用git merge命令: $ git checkout master $ git merge testing 这样testing分支中的内容会合并至master之中 6.在Intellij Idea中暂存，提交并推送暂存当做了更改之后， 右键文件，点击git分支下的add，将其放到暂存区中 提交点击git分支下的commit file，并在弹出的对话框中输入提交信息，将其提交本地库中 推送点击右下角branch分支，核对本地分支及远程库之后，点击local branches下的branch，点击push即可 7.在Vscode中暂存，提交并推送暂存当做了更改之后， 点击左边第三个，源代码管理 点击更改栏目下的test_vscode.md右边的加号，将其放到暂存的更改中 提交点击源代码管理右侧的对号，并在弹出的对话框填入提交消息 推送核对本地分支及远程库之后，在如下界面点击推送即可 参考链接： https://git-scm.com/doc","categories":[{"name":"软件技术","slug":"软件技术","permalink":"http://www.liniuniu.top/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.liniuniu.top/tags/Git/"},{"name":"代码托管","slug":"代码托管","permalink":"http://www.liniuniu.top/tags/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1/"}],"author":"Mark"},{"title":"Leetcode 430. Flatten a Multilevel Doubly Linked List 扁平化多级双向链表","slug":"Leetcode430","date":"2021-09-24T03:02:00.000Z","updated":"2021-09-24T04:38:34.413Z","comments":true,"path":"posts/345fb18b.html","link":"","permalink":"http://www.liniuniu.top/posts/345fb18b.html","excerpt":"","text":"You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below. Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list. Example 1: Input: head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12] Output: [1,2,3,7,8,11,12,9,10,4,5,6] Explanation The multilevel linked list in the input is as follows: After flattening the multilevel linked list it becomes: Example 2: Input: head = [1,2,null,3] Output: [1,3,2] Explanation: The input multilevel linked list is as follows: 1---2---NULL | 3---NULL Example 3: Input: head = [] Output: [] How multilevel linked list is represented in test case: We use the multilevel linked list from Example 1 above: 1---2---3---4---5---6--NULL | 7---8---9---10--NULL | 11--12--NULL The serialization of each level is as follows: [1,2,3,4,5,6,null] [7,8,9,10,null] [11,12,null] To serialize all levels together we will add nulls in each level to signify no node connects to the upper node of the previous level. The serialization becomes: [1,2,3,4,5,6,null] [null,null,7,8,9,10,null] [null,11,12,null] Merging the serialization of each level and removing trailing nulls we obtain: [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12] Constraints: The number of Nodes will not exceed 1000. 1 &lt;= Node.val &lt;= 10^5 分析：这道题给出一个多级双向链表，要求将其扁平化，也就是将多级转变为单极，这种形式与二叉树链表的先序遍历非常相似，因此优先考虑深度优先搜索遍历 方法从head开始遍历链表，当遇到存在child节点时，则保存node.next，然后dfs node.child（与二叉树先序优先搜索遍历相似），将node.next与node.child构建先后续关系，node.child置于null。dfs最终得到child节点的尾节点，将尾节点和之前保存的node.next构建先后续关系，dfs深层遍历后回溯到之前的层，把每一层child节点的前后构建完成。 代码* // Definition for a Node. class Node { public int val; public Node prev; public Node next; public Node child; }; */ class Solution { public Node flatten(Node head) { dfs(head); return head; } public Node dfs(Node node) { Node cur=node; Node last=null; while(cur!=null) { Node next=cur.next; if(cur.child!=null) { Node childLast=dfs(cur.child); next=cur.next; cur.next=cur.child; cur.child.prev=cur; if(next!=null) { childLast.next=next; next.prev=childLast; } cur.child=null; last=childLast; } else { last=cur; } cur=next; } return last; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"},{"name":"dfs","slug":"dfs","permalink":"http://www.liniuniu.top/tags/dfs/"}],"author":"Mark"},{"title":"Leetcode 58. Length of Last Word 最后一个单词的长度","slug":"Leetcode58","date":"2021-09-23T12:31:00.000Z","updated":"2021-09-23T12:37:31.725Z","comments":true,"path":"posts/776c8164.html","link":"","permalink":"http://www.liniuniu.top/posts/776c8164.html","excerpt":"","text":"Given a string s consisting of some words separated by some number of spaces, return the length of the last word in the string. A word is a maximal substring consisting of non-space characters only. Example 1: Input: s = \"Hello World\" Output: 5 Explanation: The last word is \"World\" with length 5. Example 2: Input: s = \" fly me to the moon \" Output: 4 Explanation: The last word is \"moon\" with length 4. Example 3: Input: s = \"luffy is still joyboy\" Output: 6 Explanation: The last word is \"joyboy\" with length 6. Constraints: 1 &lt;= s.length &lt;= 104 s consists of only English letters and spaces ' '. There will be at least one word in s. 分析：这道题求一个句子之中最后一个单词的长度，最简单的方法就是判断是不是为空格，是空格就把sum置0，否则累加，最终得到的就是最后一个单词的长度 方法遇到空格就把sum置0，否则累加，最终得到最后一个单词的长度 代码class Solution { public int lengthOfLastWord(String s) { int sum=0;int ans=0; for(char ch:s.toCharArray()) { if(ch!=' ') { sum++; ans=sum; } else { sum=0; } } return ans; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"},{"title":"Leetcode 673. Number of Longest Increasing Subsequence 最长递增子序列的个数","slug":"Leetcode673","date":"2021-09-23T12:04:00.000Z","updated":"2021-09-24T03:25:57.057Z","comments":true,"path":"posts/e88ed89b.html","link":"","permalink":"http://www.liniuniu.top/posts/e88ed89b.html","excerpt":"","text":"Given an integer array nums, return the number of longest increasing subsequences. Notice that the sequence has to be strictly increasing. Example 1: Input: nums = [1,3,5,4,7] Output: 2 Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7]. Example 2: Input: nums = [2,2,2,2,2] Output: 5 Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5. Constraints: 1 &lt;= nums.length &lt;= 2000 -10^6 &lt;= nums[i] &lt;= 10^6 分析：这道题给出一个数组，要求求出最长的递增的子序列的总数，这里有两个限定词，最长和递增。题目为求总数，可以用动态规划方法，限定词为最长，可以设置为一个dp数组，递增放到循环里进行判断，故设置len[i]表示结尾为nums[i]的最长子序列的长度，cnt[i]表示结尾为nums[i]的最长子序列的数量。 方法对于数组中或中的每个元素，它们都带有三个字段：1）最大增加/减少长度以当前元素结束，2）它自己的值，3）最大长度的总数，并且每次我们访问一个元素时，我们都会使用它来更新1和 3设置len[i]表示结尾为nums[i]的最长子序列的长度，cnt[i]表示结尾为nums[i]的最长子序列的数量。 代码class Solution { public int findNumberOfLIS(int[] nums) { int n=nums.length; int ans=0;int max=0; int[] len=new int[n];//长度 int[] cnt=new int[n];//个数 for(int i=0;i&lt;n;i++) { len[i]=cnt[i]=1; for(int j=0;j&lt;i;j++) { if(nums[i]&gt;nums[j]) { if(len[i]==len[j]+1) { cnt[i]+=cnt[j]; } else if(len[i]&lt;len[j]+1) { len[i]=len[j]+1; cnt[i]=cnt[j]; } } } //求最大递增子序列的数量 if(max==len[i]) { ans+=cnt[i]; } if(max&lt;len[i]) { ans=cnt[i]; max=len[i]; } } return ans; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"},{"title":"Leetcode 650. 2 Keys Keyboard 只有两个键的键盘","slug":"Leetcode650","date":"2021-09-23T10:54:00.000Z","updated":"2021-09-23T12:37:31.719Z","comments":true,"path":"posts/c4b7fa82.html","link":"","permalink":"http://www.liniuniu.top/posts/c4b7fa82.html","excerpt":"","text":"There is only one character 'A' on the screen of a notepad. You can perform two operations on this notepad for each step: Copy All: You can copy all the characters present on the screen (a partial copy is not allowed). Paste: You can paste the characters which are copied last time. Given an integer n, return the minimum number of operations to get the character 'A' exactly n times on the screen. Example 1: Input: n = 3 Output: 3 Explanation: Intitally, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'. Example 2: Input: n = 1 Output: 0 Constraints: 1 &lt;= n &lt;= 1000 分析：这道题主要说，如果要从A获得AA，需要2个额外的步骤（全部复制然后粘贴），如果要从A获得AAA，我们需要三个额外的步骤，（全部复制，然后粘贴，再次粘贴）。为了生成 AAAA，我们需要 AA 的 2 个步骤。但是，要获得 AAAAAAAA，最好的方法是从 AAAA 获得，有 2 个步骤（全部复制然后粘贴）本质上，我们找到了下一个更短的序列，它可以被复制然后多次粘贴以生成所需的序列。当我们找到一个可以完美分割我们所需序列长度的长度时，我们就不需要检查任何更短的序列。 方法看到字符串相关，最容易想到的便是动态规划，动态规划方程经验证可写为，dp[i]=dp[j]+i/j，其中dp[i]是目前得到记事本相应字符个数所需的最少操作次数，dp[j]为之前（最终匹配到的为i的约数）。如i=9，j=3，那么经此动态规划方程运算，则dp[i]会在dp[j]的基础上加3，相当于复制，粘贴，粘贴。 代码class Solution { public int minSteps(int n) { int[] dp=new int[n+1]; for(int i=2;i&lt;=n;i++) { dp[i]=i; for(int j=i-1;j&gt;1;j--) { if(i%j==0) { dp[i]=dp[j]+i/j; break; } } } return dp[n]; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"},{"title":"Leetcode 326. Power of Three 3的幂","slug":"Leetcode326","date":"2021-09-22T06:37:00.000Z","updated":"2021-09-23T11:13:00.532Z","comments":true,"path":"posts/3e4049d7.html","link":"","permalink":"http://www.liniuniu.top/posts/3e4049d7.html","excerpt":"","text":"Given an integer n, return true if it is a power of three. Otherwise, return false. An integer n is a power of three, if there exists an integer x such that n == 3x. Example 1: Input: n = 27 Output: true Example 2: Input: n = 0 Output: false Example 3: Input: n = 9 Output: true Example 4: Input: n = 45 Output: false Constraints: -2^31 &lt;= n &lt;= 2^31 - 1 分析：这道题要判断n是否是3的幂方法一最容易想到的思路是，用n不断除3，如果能除到1且无余数则为3的幂，否则不是。整个过程的时间复杂度为log(n)，时间复杂度为log(1) 代码class Solution { public boolean isPowerOfThree(int n) { while(n!=0&amp;&amp;n%3==0) { n/=3; } return n==1; } } 方法二在int可表示的范围内，3的最大幂为3的19次幂，这个数字仅是3的幂数的公倍数，所以可以从n是否3的19次幂的约数来判断。这个过程仅做了常数级运算，时间复杂度为log(1)，空间复杂度为log(1) 代码class Solution { public boolean isPowerOfThree(int n) { int max=(int)Math.pow(3,19); if(n&gt;0&amp;&amp;max%n==0) { return true; } return false; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"},{"title":"Leetcode 725. Split Linked List in Parts 分隔链表","slug":"Leetcode725","date":"2021-09-22T06:34:00.000Z","updated":"2021-09-23T11:13:30.518Z","comments":true,"path":"posts/b75f9389.html","link":"","permalink":"http://www.liniuniu.top/posts/b75f9389.html","excerpt":"","text":"Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts. The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null. The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later. Return an array of the k parts. Example 1: Input: head = [1,2,3], k = 5 Output: [[1],[2],[3],[],[]] Explanation: The first element output[0] has output[0].val = 1, output[0].next = null. The last element output[4] is null, but its string representation as a ListNode is []. Example 2: Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3 Output: [[1,2,3,4],[5,6,7],[8,9,10]] Explanation: The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts. Constraints: The number of nodes in the list is in the range [0, 1000]. 0 &lt;= Node.val &lt;= 1000 1 &lt;= k &lt;= 50 这道题要把一个ListNode链表，平均分隔为k段，有部分数量可能多一个，放到前面。对于一道 Medium 题而言，思路比较清晰，主要就是考察了一个对链表的使用和对细节的把握，可以使用两个for循环，把被分割的每一段链表的开端设为上一段的next， res[i]=cur; int part=every+(suff&gt;i?1:0); 对于每一段链表的结尾，则采用如下方式，让末尾的后置设为null ListNode next=cur.next; cur.next=null; cur=next; 然后比较这个距离和，跟总距离减去该距离所得结果之间的较小值返回即可，参见代码如下： 解法： class Solution { public ListNode[] splitListToParts(ListNode head, int k) { int sum=0; ListNode cur=head; while(head!=null) { sum++; head=head.next; } int suff=sum%k;int every=sum/k; ListNode[] res=new ListNode[k]; for(int i=0;i&lt;k&amp;&amp;cur!=null;i++) { res[i]=cur; int part=every+(suff&gt;i?1:0); for(int j=1;j&lt;part;j++) { cur=cur.next; } ListNode next=cur.next; cur.next=null; cur=next; } return res; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"}],"categories":[{"name":"软件技术","slug":"软件技术","permalink":"http://www.liniuniu.top/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"},{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.liniuniu.top/tags/Git/"},{"name":"代码托管","slug":"代码托管","permalink":"http://www.liniuniu.top/tags/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1/"},{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"},{"name":"dfs","slug":"dfs","permalink":"http://www.liniuniu.top/tags/dfs/"}]}