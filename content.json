{"meta":{"title":"Mark","subtitle":"Markの博客","description":"硕士研究生 | 计算机技术 | 软件开发","author":"Mark","url":"http://www.liniuniu.top","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-22T08:04:15.434Z","comments":true,"path":"404.html","permalink":"http://www.liniuniu.top/404.html","excerpt":"","text":""},{"title":"","date":"2021-09-22T08:04:15.502Z","updated":"2021-09-22T08:04:15.502Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"http://www.liniuniu.top/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-22T08:04:15.441Z","comments":true,"path":"List/index.html","permalink":"http://www.liniuniu.top/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"","date":"2021-09-22T08:04:15.503Z","updated":"2021-09-22T08:04:15.503Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"http://www.liniuniu.top/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-22T08:04:15.501Z","comments":true,"path":"about/index.html","permalink":"http://www.liniuniu.top/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-22T08:04:15.501Z","comments":true,"path":"archives/index.html","permalink":"http://www.liniuniu.top/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-09-22T08:04:15.502Z","comments":true,"path":"categories/index.html","permalink":"http://www.liniuniu.top/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-09-22T08:04:15.503Z","comments":true,"path":"friends/index.html","permalink":"http://www.liniuniu.top/friends/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-09-22T08:04:15.502Z","comments":true,"path":"census/index.html","permalink":"http://www.liniuniu.top/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-09-22T09:01:00.000Z","updated":"2021-09-22T09:01:56.551Z","comments":true,"path":"contact/index.html","permalink":"http://www.liniuniu.top/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Markの友链信息 博客名称: Markの博客 博客网址: http://www.liniuniu.top 博客头像: https://z3.ax1x.com/2021/09/22/4UQnjP.jpg 博客介绍: Experience is the father of wisdom and memory the mother"},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-22T08:04:15.503Z","comments":true,"path":"resource/index.html","permalink":"http://www.liniuniu.top/resource/index.html","excerpt":"","text":""},{"title":"资源","date":"2020-02-10T14:07:08.000Z","updated":"2021-09-22T02:41:18.956Z","comments":false,"path":"resources/index.html","permalink":"http://www.liniuniu.top/resources/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-22T08:04:15.503Z","comments":true,"path":"tags/index.html","permalink":"http://www.liniuniu.top/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-09-22T12:33:48.515Z","updated":"2021-09-22T08:04:15.438Z","comments":true,"path":"List/galleries/index.html","permalink":"http://www.liniuniu.top/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-09-22T08:04:15.441Z","comments":true,"path":"List/movies/index.html","permalink":"http://www.liniuniu.top/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-22T08:04:15.442Z","comments":true,"path":"List/tools/index.html","permalink":"http://www.liniuniu.top/List/tools/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-09-22T08:04:15.441Z","comments":true,"path":"List/music/index.html","permalink":"http://www.liniuniu.top/List/music/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-09-22T12:33:35.648Z","updated":"2021-09-22T08:04:15.439Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-09-22T12:33:00.851Z","updated":"2021-09-22T08:04:15.438Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-09-22T08:04:15.439Z","updated":"2021-09-22T08:04:15.439Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-09-22T08:04:15.439Z","updated":"2021-09-22T08:04:15.439Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-09-22T08:04:15.439Z","updated":"2021-09-22T08:04:15.439Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-09-22T08:04:15.440Z","updated":"2021-09-22T08:04:15.440Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-09-22T08:04:15.440Z","updated":"2021-09-22T08:04:15.440Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-09-22T08:04:15.440Z","updated":"2021-09-22T08:04:15.440Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-09-22T08:04:15.440Z","updated":"2021-09-22T08:04:15.440Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-09-22T08:04:15.440Z","updated":"2021-09-22T08:04:15.440Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-09-22T08:04:15.441Z","updated":"2021-09-22T08:04:15.441Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-09-22T08:04:15.441Z","updated":"2021-09-22T08:04:15.441Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"http://www.liniuniu.top/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"Leetcode 58. Length of Last Word 最后一个单词的长度","slug":"Leetcode58","date":"2021-09-23T12:31:00.000Z","updated":"2021-09-23T12:37:31.725Z","comments":true,"path":"posts/776c8164.html","link":"","permalink":"http://www.liniuniu.top/posts/776c8164.html","excerpt":"","text":"Given a string s consisting of some words separated by some number of spaces, return the length of the last word in the string. A word is a maximal substring consisting of non-space characters only. Example 1: Input: s = \"Hello World\" Output: 5 Explanation: The last word is \"World\" with length 5. Example 2: Input: s = \" fly me to the moon \" Output: 4 Explanation: The last word is \"moon\" with length 4. Example 3: Input: s = \"luffy is still joyboy\" Output: 6 Explanation: The last word is \"joyboy\" with length 6. Constraints: 1 &lt;= s.length &lt;= 104 s consists of only English letters and spaces ' '. There will be at least one word in s. 分析：这道题求一个句子之中最后一个单词的长度，最简单的方法就是判断是不是为空格，是空格就把sum置0，否则累加，最终得到的就是最后一个单词的长度 方法遇到空格就把sum置0，否则累加，最终得到最后一个单词的长度 代码class Solution { public int lengthOfLastWord(String s) { int sum=0;int ans=0; for(char ch:s.toCharArray()) { if(ch!=' ') { sum++; ans=sum; } else { sum=0; } } return ans; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"},{"title":"Leetcode 673. Number of Longest Increasing Subsequence 最长递增子序列的个数","slug":"Leetcode673","date":"2021-09-23T12:04:00.000Z","updated":"2021-09-23T12:37:31.730Z","comments":true,"path":"posts/e88ed89b.html","link":"","permalink":"http://www.liniuniu.top/posts/e88ed89b.html","excerpt":"","text":"Given an integer array nums, return the number of longest increasing subsequences. Notice that the sequence has to be strictly increasing. Example 1: Input: nums = [1,3,5,4,7] Output: 2 Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7]. Example 2: Input: nums = [2,2,2,2,2] Output: 5 Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5. Constraints: 1 &lt;= nums.length &lt;= 2000 -10^6 &lt;= nums[i] &lt;= 10^6 分析：这道题给出一个数组，要求求出最长的递增的子序列的总数，这里有两个限定词，最长和递增。题目为求总数，可以用动态规划方法，限定词为最长，可以设置为一个dp数组，递增放到循环里进行判断，故设置len[i]表示结尾为nums[i]的最长子序列的长度，cnt[i]表示结尾为nums[i]的最长子序列的数量。 方法对于数组中或中的每个元素，它们都带有三个字段：1）最大增加/减少长度以当前元素结束，2）它自己的值，3）最大长度的总数，并且每次我们访问一个元素时，我们都会使用它来更新1和 3设置len[i]表示结尾为nums[i]的最长子序列的长度，cnt[i]表示结尾为nums[i]的最长子序列的数量。 代码class Solution { public int findNumberOfLIS(int[] nums) { int n=nums.length; int ans=0;int max=0; int[] len=new int[n];//长度 int[] cnt=new int[n];//个数 for(int i=0;i&lt;n;i++) { len[i]=cnt[i]=1; for(int j=0;j&lt;i;j++) { if(nums[i]&gt;nums[j]) { if(len[i]==len[j]+1) { cnt[i]+=cnt[j]; } else if(len[i]&lt;len[j]+1) { len[i]=len[j]+1; cnt[i]=cnt[j]; } } } //求最大递增子序列的数量 if(max==len[i]) { ans+=cnt[i]; } if(max&lt;len[i]) { ans=cnt[i]; max=len[i]; } } return ans; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"},{"title":"Leetcode 650. 2 Keys Keyboard 只有两个键的键盘","slug":"Leetcode650","date":"2021-09-23T10:54:00.000Z","updated":"2021-09-23T12:37:31.719Z","comments":true,"path":"posts/c4b7fa82.html","link":"","permalink":"http://www.liniuniu.top/posts/c4b7fa82.html","excerpt":"","text":"There is only one character 'A' on the screen of a notepad. You can perform two operations on this notepad for each step: Copy All: You can copy all the characters present on the screen (a partial copy is not allowed). Paste: You can paste the characters which are copied last time. Given an integer n, return the minimum number of operations to get the character 'A' exactly n times on the screen. Example 1: Input: n = 3 Output: 3 Explanation: Intitally, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'. Example 2: Input: n = 1 Output: 0 Constraints: 1 &lt;= n &lt;= 1000 分析：这道题主要说，如果要从A获得AA，需要2个额外的步骤（全部复制然后粘贴），如果要从A获得AAA，我们需要三个额外的步骤，（全部复制，然后粘贴，再次粘贴）。为了生成 AAAA，我们需要 AA 的 2 个步骤。但是，要获得 AAAAAAAA，最好的方法是从 AAAA 获得，有 2 个步骤（全部复制然后粘贴）本质上，我们找到了下一个更短的序列，它可以被复制然后多次粘贴以生成所需的序列。当我们找到一个可以完美分割我们所需序列长度的长度时，我们就不需要检查任何更短的序列。 方法看到字符串相关，最容易想到的便是动态规划，动态规划方程经验证可写为，dp[i]=dp[j]+i/j，其中dp[i]是目前得到记事本相应字符个数所需的最少操作次数，dp[j]为之前（最终匹配到的为i的约数）。如i=9，j=3，那么经此动态规划方程运算，则dp[i]会在dp[j]的基础上加3，相当于复制，粘贴，粘贴。 代码class Solution { public int minSteps(int n) { int[] dp=new int[n+1]; for(int i=2;i&lt;=n;i++) { dp[i]=i; for(int j=i-1;j&gt;1;j--) { if(i%j==0) { dp[i]=dp[j]+i/j; break; } } } return dp[n]; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"},{"title":"Leetcode 326. Power of Three 3的幂","slug":"Leetcode326","date":"2021-09-22T06:37:00.000Z","updated":"2021-09-23T11:13:00.532Z","comments":true,"path":"posts/3e4049d7.html","link":"","permalink":"http://www.liniuniu.top/posts/3e4049d7.html","excerpt":"","text":"Given an integer n, return true if it is a power of three. Otherwise, return false. An integer n is a power of three, if there exists an integer x such that n == 3x. Example 1: Input: n = 27 Output: true Example 2: Input: n = 0 Output: false Example 3: Input: n = 9 Output: true Example 4: Input: n = 45 Output: false Constraints: -2^31 &lt;= n &lt;= 2^31 - 1 分析：这道题要判断n是否是3的幂方法一最容易想到的思路是，用n不断除3，如果能除到1且无余数则为3的幂，否则不是。整个过程的时间复杂度为log(n)，时间复杂度为log(1) 代码class Solution { public boolean isPowerOfThree(int n) { while(n!=0&amp;&amp;n%3==0) { n/=3; } return n==1; } } 方法二在int可表示的范围内，3的最大幂为3的19次幂，这个数字仅是3的幂数的公倍数，所以可以从n是否3的19次幂的约数来判断。这个过程仅做了常数级运算，时间复杂度为log(1)，空间复杂度为log(1) 代码class Solution { public boolean isPowerOfThree(int n) { int max=(int)Math.pow(3,19); if(n&gt;0&amp;&amp;max%n==0) { return true; } return false; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"},{"title":"Leetcode 725. Split Linked List in Parts 分隔链表","slug":"Leetcode725","date":"2021-09-22T06:34:00.000Z","updated":"2021-09-23T11:13:30.518Z","comments":true,"path":"posts/b75f9389.html","link":"","permalink":"http://www.liniuniu.top/posts/b75f9389.html","excerpt":"","text":"Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts. The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null. The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later. Return an array of the k parts. Example 1: Input: head = [1,2,3], k = 5 Output: [[1],[2],[3],[],[]] Explanation: The first element output[0] has output[0].val = 1, output[0].next = null. The last element output[4] is null, but its string representation as a ListNode is []. Example 2: Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3 Output: [[1,2,3,4],[5,6,7],[8,9,10]] Explanation: The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts. Constraints: The number of nodes in the list is in the range [0, 1000]. 0 &lt;= Node.val &lt;= 1000 1 &lt;= k &lt;= 50 这道题要把一个ListNode链表，平均分隔为k段，有部分数量可能多一个，放到前面。对于一道 Medium 题而言，思路比较清晰，主要就是考察了一个对链表的使用和对细节的把握，可以使用两个for循环，把被分割的每一段链表的开端设为上一段的next， res[i]=cur; int part=every+(suff&gt;i?1:0); 对于每一段链表的结尾，则采用如下方式，让末尾的后置设为null ListNode next=cur.next; cur.next=null; cur=next; 然后比较这个距离和，跟总距离减去该距离所得结果之间的较小值返回即可，参见代码如下： 解法： class Solution { public ListNode[] splitListToParts(ListNode head, int k) { int sum=0; ListNode cur=head; while(head!=null) { sum++; head=head.next; } int suff=sum%k;int every=sum/k; ListNode[] res=new ListNode[k]; for(int i=0;i&lt;k&amp;&amp;cur!=null;i++) { res[i]=cur; int part=every+(suff&gt;i?1:0); for(int j=1;j&lt;part;j++) { cur=cur.next; } ListNode next=cur.next; cur.next=null; cur=next; } return res; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}],"author":"Mark"}],"categories":[{"name":"算法","slug":"算法","permalink":"http://www.liniuniu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.liniuniu.top/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.liniuniu.top/tags/algorithm/"}]}